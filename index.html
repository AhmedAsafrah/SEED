<!DOCTYPE html>
<html lang="ar" dir="rtl">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>Ø¨ÙŠØ¦Ø© Ø¯Ø¹Ù… Ø§ÙØªØ±Ø§Ø¶ÙŠØ© Ù„Ù„Ø£Ø·ÙØ§Ù„ Ø§Ù„Ù…ØµØ§Ø¨ÙŠÙ† Ø¨Ø§Ù„ØªÙˆØ­Ø¯</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Noto+Sans+Arabic:wght@400;600;700&display=swap"
      rel="stylesheet"
    />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/howler/2.2.3/howler.min.js"></script>
    <style>
      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }
      body {
        font-family: "Noto Sans Arabic", sans-serif;
        overflow: hidden;
        background: black;
        width: 100vw;
        height: 100vh;
        position: fixed;
        top: 0;
        left: 0;
      }
      select,
      input,
      button {
        font-size: clamp(1rem, 2.5vw, 1.25rem);
        font-family: "Noto Sans Arabic", sans-serif;
      }

      /* Responsive Interface Containers */
      .interface-container {
        max-width: 90vw;
        max-height: 85vh;
        overflow-y: auto;
        padding: clamp(1rem, 4vw, 2rem);
        border-radius: clamp(0.5rem, 2vw, 1rem);
      }

      /* Enhanced Button Styles */
      .level-btn, .room-btn {
        transition: transform 0.3s ease, background-color 0.3s ease;
        border: 2px solid white;
        padding: clamp(1rem, 3vw, 1.5rem);
        position: relative;
        overflow: hidden;
        cursor: pointer;
        font-size: clamp(1rem, 2.5vw, 1.25rem);
        min-height: 60px;
        display: flex;
        align-items: center;
        justify-content: center;
        text-align: center;
      }
      
      .level-btn:hover, .room-btn:hover {
        transform: scale(1.05);
      }
      
      .level-btn:hover {
        background-color: #34d399;
      }
      
      .room-btn:hover {
        background-color: #60a5fa;
      }

      .level-btn::after {
        content: "âœ¨";
        position: absolute;
        top: 10px;
        right: 10px;
        font-size: clamp(1rem, 3vw, 1.5rem);
        opacity: 0;
        transition: opacity 0.3s ease;
      }
      .level-btn:hover::after {
        opacity: 1;
      }
      
      .room-btn::after {
        content: "ğŸŒŸ";
        position: absolute;
        top: 10px;
        right: 10px;
        font-size: clamp(1rem, 3vw, 1.5rem);
        opacity: 0;
        transition: opacity 0.3s ease;
      }
      .room-btn:hover::after {
        opacity: 1;
      }

      /* Exit Button Responsive */
      #exit-room-btn {
        position: fixed;
        bottom: clamp(15px, 3vh, 25px);
        left: clamp(15px, 3vw, 25px);
        z-index: 10;
        display: none;
        cursor: pointer;
        padding: clamp(0.5rem, 2vw, 1rem);
        font-size: clamp(0.9rem, 2vw, 1.1rem);
        min-width: 80px;
        min-height: 45px;
      }

      .hidden {
        display: none !important;
      }

      /* Enhanced Range Sliders */
      input[type="range"] {
        width: 100%;
        margin: 10px 0;
        -webkit-appearance: none;
        appearance: none;
        height: clamp(6px, 1.5vw, 10px);
        border-radius: 5px;
        background: #ddd;
        outline: none;
        transition: all 0.3s ease;
      }

      input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        height: clamp(20px, 4vw, 30px);
        width: clamp(20px, 4vw, 30px);
        border-radius: 50%;
        background: #04aa6d;
        cursor: pointer;
        transition: all 0.3s ease;
        box-shadow: 0 0 10px rgba(4, 170, 109, 0.5);
      }

      input[type="range"]::-webkit-slider-thumb:hover {
        transform: scale(1.2);
        box-shadow: 0 0 15px rgba(4, 170, 109, 0.8);
      }

      input[type="range"]::-moz-range-thumb {
        height: clamp(20px, 4vw, 30px);
        width: clamp(20px, 4vw, 30px);
        border-radius: 50%;
        background: #04aa6d;
        cursor: pointer;
        border: none;
        transition: all 0.3s ease;
        box-shadow: 0 0 10px rgba(4, 170, 109, 0.5);
      }

      input[type="range"]::-moz-range-thumb:hover {
        transform: scale(1.2);
        box-shadow: 0 0 15px rgba(4, 170, 109, 0.8);
      }

      /* Responsive Indicators */
      .volume-indicator {
        position: fixed;
        top: clamp(10px, 2vh, 15px);
        right: clamp(10px, 2vw, 15px);
        background: rgba(0, 0, 0, 0.7);
        color: white;
        padding: clamp(8px, 2vw, 12px);
        border-radius: 5px;
        font-size: clamp(0.8rem, 2vw, 1rem);
        z-index: 100;
        display: none;
        transition: all 0.3s ease;
        max-width: 200px;
      }

      .brightness-indicator {
        position: fixed;
        top: clamp(50px, 8vh, 70px);
        right: clamp(10px, 2vw, 15px);
        background: rgba(255, 215, 0, 0.8);
        color: black;
        padding: clamp(8px, 2vw, 12px);
        border-radius: 5px;
        font-size: clamp(0.8rem, 2vw, 1rem);
        z-index: 100;
        display: none;
        transition: all 0.3s ease;
        max-width: 200px;
      }

      /* Student & Level Info */
      .student-info {
        position: fixed;
        top: clamp(10px, 2vh, 15px);
        left: clamp(10px, 2vw, 15px);
        background: rgba(34, 197, 94, 0.9);
        color: white;
        padding: clamp(8px, 2vw, 12px);
        border-radius: 8px;
        font-size: clamp(0.9rem, 2.2vw, 1.1rem);
        font-weight: bold;
        z-index: 100;
        display: none;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        max-width: 250px;
        word-wrap: break-word;
      }

      .level-info {
        position: fixed;
        top: clamp(50px, 8vh, 70px);
        left: clamp(10px, 2vw, 15px);
        background: rgba(59, 130, 246, 0.9);
        color: white;
        padding: clamp(6px, 1.5vw, 10px);
        border-radius: 6px;
        font-size: clamp(0.8rem, 2vw, 1rem);
        z-index: 100;
        display: none;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        max-width: 220px;
        word-wrap: break-word;
      }

      .error-message {
        color: #ff6b6b;
        font-size: clamp(0.8rem, 2vw, 1rem);
        margin-top: 5px;
        display: none;
      }

      /* Mobile-First Responsive Design */
      @media screen and (max-width: 480px) {
        /* Mobile Phones */
        .interface-container {
          padding: 1rem;
          max-width: 95vw;
          max-height: 90vh;
        }
        
        .level-btn, .room-btn {
          padding: 1.2rem 0.8rem;
          margin: 0.5rem 0;
          font-size: 1.1rem;
          min-height: 65px;
        }
        
        #exit-room-btn {
          bottom: 10px;
          left: 10px;
          padding: 0.8rem;
          font-size: 1rem;
          min-width: 90px;
        }
        
        input[type="text"] {
          padding: 1rem;
          font-size: 1.1rem;
        }
        
        h1 {
          font-size: 1.8rem !important;
          margin-bottom: 1rem;
        }
        
        button {
          padding: 1rem;
          font-size: 1.1rem;
          min-height: 50px;
        }
        
        .volume-indicator, .brightness-indicator {
          font-size: 0.9rem;
          padding: 10px;
          top: 10px;
          right: 10px;
        }
        
        .brightness-indicator {
          top: 55px;
        }
        
        .student-info {
          font-size: 1rem;
          padding: 10px;
          max-width: 180px;
        }
        
        .level-info {
          font-size: 0.9rem;
          padding: 8px;
          max-width: 160px;
          top: 55px;
        }
      }

      @media screen and (min-width: 481px) and (max-width: 768px) {
        /* Tablets */
        .interface-container {
          padding: 1.5rem;
          max-width: 90vw;
        }
        
        .level-btn, .room-btn {
          padding: 1.4rem;
          font-size: 1.2rem;
          min-height: 70px;
        }
        
        h1 {
          font-size: 2.2rem !important;
        }
        
        input[type="text"] {
          padding: 1.2rem;
          font-size: 1.2rem;
        }
        
        button {
          padding: 1.2rem;
          font-size: 1.2rem;
        }
      }

      @media screen and (min-width: 769px) and (max-width: 1024px) {
        /* Large Tablets / Small Laptops */
        .interface-container {
          padding: 2rem;
          max-width: 85vw;
        }
        
        .level-btn, .room-btn {
          padding: 1.5rem;
          font-size: 1.3rem;
          min-height: 75px;
        }
        
        h1 {
          font-size: 2.5rem !important;
        }
      }

      @media screen and (min-width: 1025px) {
        /* Desktop */
        .interface-container {
          padding: 2.5rem;
          max-width: 80vw;
        }
        
        .level-btn, .room-btn {
          padding: 1.5rem;
          font-size: 1.25rem;
          min-height: 80px;
        }
        
        h1 {
          font-size: 3rem !important;
        }
      }

      /* Touch-friendly interactions */
      @media (pointer: coarse) {
        button, .level-btn, .room-btn {
          min-height: 48px;
          min-width: 48px;
        }
        
        input[type="range"]::-webkit-slider-thumb {
          height: 32px;
          width: 32px;
        }
        
        input[type="range"]::-moz-range-thumb {
          height: 32px;
          width: 32px;
        }
      }

      /* Landscape mobile optimization */
      @media screen and (max-height: 480px) and (orientation: landscape) {
        .interface-container {
          max-height: 95vh;
          overflow-y: auto;
          padding: 1rem;
        }
        
        h1 {
          font-size: 1.5rem !important;
          margin-bottom: 0.5rem;
        }
        
        .level-btn, .room-btn {
          padding: 0.8rem;
          margin: 0.3rem 0;
          min-height: 50px;
        }
        
        #exit-room-btn {
          bottom: 5px;
          left: 5px;
          padding: 0.6rem;
        }
      }

      /* High DPI Display Support */
      @media (-webkit-min-device-pixel-ratio: 2), (min-resolution: 192dpi) {
        input[type="range"]::-webkit-slider-thumb {
          border: 1px solid rgba(4, 170, 109, 0.3);
        }
        
        button, .level-btn, .room-btn {
          border-width: 1px;
        }
      }

      /* Accessibility improvements */
      @media (prefers-reduced-motion: reduce) {
        .level-btn, .room-btn {
          transition: none;
        }
        
        .level-btn:hover, .room-btn:hover {
          transform: none;
        }
        
        input[type="range"]::-webkit-slider-thumb:hover,
        input[type="range"]::-moz-range-thumb:hover {
          transform: none;
        }
      }

      /* Focus styles for keyboard navigation */
      button:focus, .level-btn:focus, .room-btn:focus {
        outline: 3px solid #4f46e5;
        outline-offset: 2px;
      }

      input:focus {
        outline: 2px solid #4f46e5;
        outline-offset: 1px;
      }

      /* Performance optimization for mobile */
      @media screen and (max-width: 768px) {
        * {
          -webkit-transform: translateZ(0);
          transform: translateZ(0);
          -webkit-backface-visibility: hidden;
          backface-visibility: hidden;
        }
      }

      /* Specific improvements for Arabic RTL text */
      input[type="text"] {
        text-align: right;
        direction: rtl;
        padding: clamp(0.8rem, 2vw, 1.2rem);
      }

      label {
        font-size: clamp(1rem, 2.5vw, 1.2rem);
        display: block;
        margin-bottom: 0.5rem;
      }

      /* Loading states */
      .loading {
        opacity: 0.6;
        pointer-events: none;
      }
    </style>
  </head>
  <body class="bg-black overflow-hidden">
    <div id="vr-scene" class="w-full h-screen"></div>

    <!-- Sound and Brightness Indicators -->
    <div id="volume-indicator" class="volume-indicator">
      ğŸ”Š Volume: <span id="volume-display">50%</span>
    </div>
    <div id="brightness-indicator" class="brightness-indicator">
      â˜€ï¸ Brightness: <span id="brightness-display">50%</span>
    </div>

    <!-- Student and Level Info Display -->
    <div id="student-info" class="student-info">
      ğŸ‘¦ Ø§Ù„Ø·Ø§Ù„Ø¨: <span id="student-name-display"></span>
    </div>
    <div id="level-info" class="level-info">
      ğŸ“š Ø§Ù„Ù…Ø³ØªÙˆÙ‰: <span id="level-name-display"></span>
    </div>

    <div
      id="ui-overlay"
      class="absolute top-0 left-0 w-full h-full flex flex-col items-center justify-center pointer-events-none"
    >
      <div
        id="settings-interface"
        class="interface-container bg-gray-800 bg-opacity-70 text-white rounded-lg mb-4 pointer-events-auto"
      >
        <h1 class="text-3xl font-bold mb-4 text-center">Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª</h1>
        <div class="flex flex-col space-y-6">
          <div>
            <label for="child-name" class="block text-lg mb-2"
              >Ø§Ø³Ù… Ø§Ù„Ø·ÙÙ„:</label
            >
            <input
              type="text"
              id="child-name"
              placeholder="Ø£Ø¯Ø®Ù„ Ø§Ø³Ù… Ø§Ù„Ø·ÙÙ„"
              class="bg-gray-700 text-white rounded w-full text-right"
              required
            />
            <div id="name-error" class="error-message">
              ÙŠØ±Ø¬Ù‰ Ø¥Ø¯Ø®Ø§Ù„ Ø§Ø³Ù… Ø§Ù„Ø·ÙÙ„
            </div>
          </div>
          <div>
            <label for="volume" class="block text-lg mb-2">Ù…Ø³ØªÙˆÙ‰ Ø§Ù„ØµÙˆØª:</label>
            <input
              type="range"
              id="volume"
              min="0"
              max="1"
              step="0.1"
              value="0.5"
              class="w-full"
            />
          </div>
          <div>
            <label for="brightness" class="block text-lg mb-2"
              >Ø´Ø¯Ø© Ø§Ù„Ø¥Ø¶Ø§Ø¡Ø©:
              <span id="brightness-value" class="font-bold text-yellow-400"
                >50%</span
              ></label
            >
            <input
              type="range"
              id="brightness"
              min="0.1"
              max="1"
              step="0.1"
              value="0.5"
              class="w-full"
            />
          </div>
          <button
            id="to-level-btn"
            class="bg-blue-500 hover:bg-blue-600 text-white rounded w-full"
          >
            Ø§Ù„ØªØ§Ù„ÙŠ
          </button>
        </div>
      </div>

      <div
        id="level-interface"
        class="interface-container bg-gray-800 bg-opacity-70 text-white rounded-xl mb-4 pointer-events-auto hidden"
      >
        <h1 class="text-4xl font-bold mb-6 text-center">Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ù…Ø³ØªÙˆÙ‰</h1>
        <div class="flex flex-col space-y-6">
          <button
            id="level-1"
            class="level-btn bg-green-500 text-white rounded-lg text-xl font-semibold shadow-lg"
          >
            Ø·Ø§Ù„Ø¨ ÙˆÙ…Ø¹Ù„Ù…
          </button>
          <button
            id="level-2"
            class="level-btn bg-green-500 text-white rounded-lg text-xl font-semibold shadow-lg"
          >
            3 Ø·Ù„Ø§Ø¨ ÙˆÙ…Ø¹Ù„Ù…
          </button>
          <button
            id="level-3"
            class="level-btn bg-green-500 text-white rounded-lg text-xl font-semibold shadow-lg"
          >
            5 Ø·Ù„Ø§Ø¨ ÙˆÙ…Ø¹Ù„Ù…
          </button>
          <button
            id="back-to-settings"
            class="bg-gray-500 hover:bg-gray-600 text-white rounded-lg text-lg"
          >
            Ø±Ø¬ÙˆØ¹
          </button>
        </div>
      </div>

      <div
        id="rooms-interface"
        class="interface-container bg-gray-800 bg-opacity-70 text-white rounded-xl mb-4 pointer-events-auto hidden"
      >
        <h1 class="text-4xl font-bold mb-6 text-center">Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„ØºØ±ÙØ©</h1>
        <div class="flex flex-col space-y-6">
          <button
            id="room-classroom"
            class="room-btn bg-blue-500 text-white rounded-lg text-xl font-semibold shadow-lg"
          >
            ØºØ±ÙØ© Ø§Ù„ØµÙ
          </button>
          <button
            id="room-cafeteria"
            class="room-btn bg-blue-500 text-white rounded-lg text-xl font-semibold shadow-lg"
          >
            ÙƒØ§ÙÙŠØªÙŠØ±ÙŠØ§
          </button>
          <button
            id="room-assembly"
            class="room-btn bg-blue-500 text-white rounded-lg text-xl font-semibold shadow-lg"
          >
            Ø·Ø§Ø¨ÙˆØ± ØµØ¨Ø§Ø­ÙŠ
          </button>
          <button
            id="back-to-levels"
            class="bg-gray-500 hover:bg-gray-600 text-white rounded-lg text-lg"
          >
            Ø±Ø¬ÙˆØ¹
          </button>
        </div>
      </div>

      <button
        id="exit-room-btn"
        class="bg-red-500 hover:bg-red-600 text-white rounded-lg text-lg pointer-events-auto"
        style="display: none"
      >
        Ø®Ø±ÙˆØ¬
      </button>
    </div>

    <script>
      // Sound system initialization
      let audioContext;
      let masterVolume = 0.5;
      let sounds = {};

      // Application state variables
      let studentName = "";
      let selectedLevel = "";
      let currentRoom = null;
      let isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
      let isTouch = 'ontouchstart' in window || navigator.maxTouchPoints > 0;

      // Initialize audio context
      function initAudio() {
        try {
          audioContext = new (window.AudioContext ||
            window.webkitAudioContext)();

          // Create sound effects using Web Audio API
          sounds.brightnessUp = createTone(800, 0.1, "sine");
          sounds.brightnessDown = createTone(400, 0.1, "sine");
          sounds.volumeUp = createTone(600, 0.1, "triangle");
          sounds.volumeDown = createTone(300, 0.1, "triangle");
          sounds.click = createTone(1000, 0.05, "square");
          sounds.success = createTone(880, 0.2, "sine");

          console.log("Audio system initialized successfully");
        } catch (error) {
          console.warn("Audio initialization failed:", error);
        }
      }

      // Create tone using Web Audio API
      function createTone(frequency, duration, waveType = "sine") {
        return function () {
          if (!audioContext) return;

          try {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);

            oscillator.frequency.setValueAtTime(
              frequency,
              audioContext.currentTime
            );
            oscillator.type = waveType;

            gainNode.gain.setValueAtTime(0, audioContext.currentTime);
            gainNode.gain.linearRampToValueAtTime(
              masterVolume * 0.3,
              audioContext.currentTime + 0.01
            );
            gainNode.gain.exponentialRampToValueAtTime(
              0.001,
              audioContext.currentTime + duration
            );

            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + duration);
          } catch (error) {
            console.warn("Sound play error:", error);
          }
        };
      }

      // Play sound effect
      function playSound(soundName) {
        if (sounds[soundName] && masterVolume > 0) {
          sounds[soundName]();
        }
      }

      // Show indicator with animation
      function showIndicator(elementId, value, unit = "%") {
        const indicator = document.getElementById(elementId);
        if (indicator) {
          indicator.style.display = "block";
          indicator.style.opacity = "1";
          indicator.style.transform = "translateX(0)";

          // Update display value
          const display = indicator.querySelector("span");
          if (display) {
            display.textContent = Math.round(value * 100) + unit;
          }

          // Auto-hide after 2 seconds
          setTimeout(() => {
            indicator.style.opacity = "0";
            indicator.style.transform = "translateX(20px)";
            setTimeout(() => {
              indicator.style.display = "none";
            }, 300);
          }, 2000);
        }
      }

      // Update student info display
      function updateStudentInfo() {
        const studentInfoEl = document.getElementById("student-info");
        const studentNameDisplay = document.getElementById(
          "student-name-display"
        );
        const levelInfoEl = document.getElementById("level-info");
        const levelNameDisplay = document.getElementById("level-name-display");

        if (studentName && studentInfoEl && studentNameDisplay) {
          studentNameDisplay.textContent = studentName;
          studentInfoEl.style.display = "block";
        }

        if (selectedLevel && levelInfoEl && levelNameDisplay) {
          levelNameDisplay.textContent = selectedLevel;
          levelInfoEl.style.display = "block";
        }
      }

      // Hide student info display
      function hideStudentInfo() {
        const studentInfoEl = document.getElementById("student-info");
        const levelInfoEl = document.getElementById("level-info");

        if (studentInfoEl) studentInfoEl.style.display = "none";
        if (levelInfoEl) levelInfoEl.style.display = "none";
      }

      // Validate student name
      function validateStudentName() {
        const nameInput = document.getElementById("child-name");
        const errorEl = document.getElementById("name-error");
        const name = nameInput.value.trim();

        if (!name) {
          errorEl.style.display = "block";
          nameInput.style.border = "2px solid #ff6b6b";
          return false;
        } else {
          errorEl.style.display = "none";
          nameInput.style.border = "";
          studentName = name;
          return true;
        }
      }

      // Reset application state
      function resetAppState() {
        studentName = "";
        selectedLevel = "";
        currentRoom = null;
        hideStudentInfo();

        // Reset forms
        const nameInput = document.getElementById("child-name");
        const errorEl = document.getElementById("name-error");
        if (nameInput) {
          nameInput.value = "";
          nameInput.style.border = "";
        }
        if (errorEl) {
          errorEl.style.display = "none";
        }
      }

      // Initialize Three.js scene with mobile optimization
      let scene,
        camera,
        renderer,
        ambientLight,
        directionalLight,
        stars,
        starGeometry,
        starMaterial;

      try {
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(
          75,
          window.innerWidth / window.innerHeight,
          0.1,
          1000
        );
        
        // Mobile-optimized renderer settings
        const rendererOptions = { 
          antialias: !isMobile, // Disable antialiasing on mobile for performance
          alpha: true,
          powerPreference: isMobile ? "low-power" : "high-performance"
        };
        
        renderer = new THREE.WebGLRenderer(rendererOptions);
        
        // Adjust pixel ratio for mobile
        const pixelRatio = isMobile ? Math.min(window.devicePixelRatio, 2) : window.devicePixelRatio;
        renderer.setPixelRatio(pixelRatio);
        
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById("vr-scene").appendChild(renderer.domElement);

        ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        directionalLight = new THREE.DirectionalLight(0xffffff, 0.3);
        directionalLight.position.set(5, 5, 5);
        scene.add(directionalLight);
      } catch (error) {
        console.error("Error initializing Three.js:", error);
      }

      // Create optimized star field
      starGeometry = new THREE.BufferGeometry();
      const starCount = isMobile ? 500 : 1000; // Reduce stars on mobile
      const positions = new Float32Array(starCount * 3);
      const colors = new Float32Array(starCount * 3);
      const sizes = new Float32Array(starCount);
      for (let i = 0; i < starCount; i++) {
        positions[i * 3] = (Math.random() - 0.5) * 100;
        positions[i * 3 + 1] = (Math.random() - 0.5) * 100;
        positions[i * 3 + 2] = (Math.random() - 0.5) * 100;
        colors[i * 3] = Math.random() * 0.5 + 0.5;
        colors[i * 3 + 1] = Math.random() * 0.5 + 0.5;
        colors[i * 3 + 2] = Math.random() * 0.5 + 0.5;
        sizes[i] = Math.random() * 2 + 1;
      }
      starGeometry.setAttribute(
        "position",
        new THREE.BufferAttribute(positions, 3)
      );
      starGeometry.setAttribute("color", new THREE.BufferAttribute(colors, 3));
      starGeometry.setAttribute("size", new THREE.BufferAttribute(sizes, 1));
      starMaterial = new THREE.PointsMaterial({
        vertexColors: true,
        sizeAttenuation: true,
        transparent: true,
        opacity: 0.8,
      });
      stars = new THREE.Points(starGeometry, starMaterial);
      scene.add(stars);

      const roomObjects = {}; // Fixed: Declared once here

      function createClassroom() {
        const group = new THREE.Group();

        // Ø£Ø±Ø¶ÙŠØ© Ø§Ù„ØµÙ Ù…Ø­Ø³Ù‘Ù†Ø©
        const floorGeometry = new THREE.PlaneGeometry(16, 14);
        const floorMaterial = new THREE.MeshLambertMaterial({
          color: 0xf0f0f0, // Ø£Ø¨ÙŠØ¶ Ù…Ø§Ø¦Ù„ Ù„Ù„Ø±Ù…Ø§Ø¯ÙŠ
        });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        group.add(floor);

        // Ø¬Ø¯Ø±Ø§Ù† Ø§Ù„ØµÙ Ù…Ø­Ø³Ù‘Ù†Ø©
        const wallMaterial = new THREE.MeshLambertMaterial({ color: 0xfffaf0 }); // Ø£Ø¨ÙŠØ¶ Ø¯Ø§ÙØ¦

        // Ø§Ù„Ø¬Ø¯Ø§Ø± Ø§Ù„Ø®Ù„ÙÙŠ
        const backWallGeometry = new THREE.PlaneGeometry(16, 4);
        const backWall = new THREE.Mesh(backWallGeometry, wallMaterial);
        backWall.position.set(0, 2, -7);
        group.add(backWall);

        // Ø§Ù„Ø¬Ø¯Ø±Ø§Ù† Ø§Ù„Ø¬Ø§Ù†Ø¨ÙŠØ©
        const sideWallGeometry = new THREE.PlaneGeometry(14, 4);
        const leftWall = new THREE.Mesh(sideWallGeometry, wallMaterial);
        leftWall.position.set(-8, 2, 0);
        leftWall.rotation.y = Math.PI / 2;
        group.add(leftWall);

        const rightWall = new THREE.Mesh(sideWallGeometry, wallMaterial);
        rightWall.position.set(8, 2, 0);
        rightWall.rotation.y = -Math.PI / 2;
        group.add(rightWall);

        // Ø§Ù„Ø³Ù‚Ù Ø§Ù„Ø±Ù…Ø§Ø¯ÙŠ Ø§Ù„Ù…Ø­Ø³Ù‘Ù†
        const ceilingGeometry = new THREE.PlaneGeometry(16, 14);
        const ceilingMaterial = new THREE.MeshLambertMaterial({
          color: 0xe8e8e8, // Ø±Ù…Ø§Ø¯ÙŠ Ø£ÙØªØ­
        });
        const ceiling = new THREE.Mesh(ceilingGeometry, ceilingMaterial);
        ceiling.rotation.x = Math.PI / 2;
        ceiling.position.set(0, 4, 0);
        group.add(ceiling);

        // Ø¥Ø¶Ø§ÙØ© Ø¥Ø¶Ø§Ø¡Ø© Ø³Ù‚Ù
        const lightGeometry = new THREE.BoxGeometry(4, 0.1, 1);
        const lightMaterial = new THREE.MeshLambertMaterial({
          color: 0xffffff,
          emissive: 0x444444,
        });
        const ceilingLight1 = new THREE.Mesh(lightGeometry, lightMaterial);
        ceilingLight1.position.set(-2, 3.9, 0);
        group.add(ceilingLight1);

        const ceilingLight2 = new THREE.Mesh(lightGeometry, lightMaterial);
        ceilingLight2.position.set(2, 3.9, 0);
        group.add(ceilingLight2);

        // Ù…ÙƒØ§ØªØ¨ Ø§Ù„Ø·Ù„Ø§Ø¨ Ù…Ø­Ø³Ù‘Ù†Ø© Ù…Ø¹ Ø£Ù„ÙˆØ§Ù† Ø£ÙØ¶Ù„
        const deskGeometry = new THREE.BoxGeometry(1.3, 0.1, 0.8);
        const deskMaterial = new THREE.MeshLambertMaterial({ color: 0xd2691e }); // Ø¨Ù†ÙŠ Ø°Ù‡Ø¨ÙŠ
        const deskLegGeometry = new THREE.BoxGeometry(0.06, 0.7, 0.06);
        const deskLegMaterial = new THREE.MeshLambertMaterial({
          color: 0x8b4513,
        });

        // ÙƒØ±Ø§Ø³ÙŠ Ù…Ø­Ø³Ù‘Ù†Ø© Ù…Ø¹ Ø£Ù„ÙˆØ§Ù† Ø£ÙØ¶Ù„
        const chairSeatGeometry = new THREE.BoxGeometry(0.45, 0.06, 0.45);
        const chairBackGeometry = new THREE.BoxGeometry(0.45, 0.6, 0.06);
        const chairMaterial = new THREE.MeshLambertMaterial({
          color: 0x4682b4, // Ø£Ø²Ø±Ù‚ ÙÙˆÙ„Ø§Ø°ÙŠ
        });
        const chairLegGeometry = new THREE.BoxGeometry(0.04, 0.45, 0.04);

        // ØªØ±ØªÙŠØ¨ Ø§Ù„Ù…ÙƒØ§ØªØ¨ ÙˆØ§Ù„ÙƒØ±Ø§Ø³ÙŠ ÙÙŠ 4 ØµÙÙˆÙ Ùˆ 3 Ø£Ø¹Ù…Ø¯Ø©
        for (let row = 0; row < 4; row++) {
          for (let col = -1; col <= 1; col++) {
            const xPos = col * 2.5;
            const zPos = -1.5 + row * 1.8;

            // Ø§Ù„Ù…ÙƒØªØ¨
            const desk = new THREE.Mesh(deskGeometry, deskMaterial);
            desk.position.set(xPos, 0.45, zPos);
            group.add(desk);

            // Ø£Ø±Ø¬Ù„ Ø§Ù„Ù…ÙƒØªØ¨
            const positions = [
              [-0.55, 0, -0.35],
              [0.55, 0, -0.35],
              [-0.55, 0, 0.35],
              [0.55, 0, 0.35],
            ];
            positions.forEach((pos) => {
              const leg = new THREE.Mesh(deskLegGeometry, deskLegMaterial);
              leg.position.set(xPos + pos[0], 0.25, zPos + pos[2]);
              group.add(leg);
            });

            // Ø§Ù„ÙƒØ±Ø³ÙŠ
            const chairSeat = new THREE.Mesh(chairSeatGeometry, chairMaterial);
            chairSeat.position.set(xPos, 0.23, zPos + 1.0);
            group.add(chairSeat);

            const chairBack = new THREE.Mesh(chairBackGeometry, chairMaterial);
            chairBack.position.set(xPos, 0.5, zPos + 0.75);
            group.add(chairBack);

            // Ø£Ø±Ø¬Ù„ Ø§Ù„ÙƒØ±Ø³ÙŠ
            const chairPositions = [
              [-0.18, 0, -0.18],
              [0.18, 0, -0.18],
              [-0.18, 0, 0.18],
              [0.18, 0, 0.18],
            ];
            chairPositions.forEach((pos) => {
              const chairLeg = new THREE.Mesh(chairLegGeometry, chairMaterial);
              chairLeg.position.set(xPos + pos[0], 0.125, zPos + 1.0 + pos[2]);
              group.add(chairLeg);
            });
          }
        }

        // Ø§Ù„Ø³Ø¨ÙˆØ±Ø© Ø§Ù„Ø°ÙƒÙŠØ© Ø§Ù„Ù…Ø­Ø³Ù‘Ù†Ø©
        const boardFrameGeometry = new THREE.BoxGeometry(5, 2.8, 0.15);
        const boardFrameMaterial = new THREE.MeshLambertMaterial({
          color: 0x2f4f4f, // Ø±Ù…Ø§Ø¯ÙŠ Ø¯Ø§ÙƒÙ†
        });
        const boardFrame = new THREE.Mesh(
          boardFrameGeometry,
          boardFrameMaterial
        );
        boardFrame.position.set(0, 2, -6.9);
        group.add(boardFrame);

        const boardGeometry = new THREE.PlaneGeometry(4.6, 2.4);
        const boardMaterial = new THREE.MeshLambertMaterial({
          color: 0x000000, // Ø£Ø³ÙˆØ¯ Ù„Ù„Ø³Ø¨ÙˆØ±Ø© Ø§Ù„Ø°ÙƒÙŠØ©
        });
        const board = new THREE.Mesh(boardGeometry, boardMaterial);
        board.position.set(0, 2, -6.8);
        group.add(board);

        // Ù…ÙƒØªØ¨ Ø§Ù„Ù…Ø¹Ù„Ù… Ø§Ù„Ù…Ø­Ø³Ù‘Ù†
        const teacherDeskGeometry = new THREE.BoxGeometry(1.8, 0.12, 1.0);
        const teacherDeskMaterial = new THREE.MeshLambertMaterial({
          color: 0x8b4513,
        });
        const teacherDesk = new THREE.Mesh(
          teacherDeskGeometry,
          teacherDeskMaterial
        );
        teacherDesk.position.set(4, 0.56, -5);
        group.add(teacherDesk);

        // Ø£Ø±Ø¬Ù„ Ù…ÙƒØªØ¨ Ø§Ù„Ù…Ø¹Ù„Ù…
        const teacherDeskLegPositions = [
          [-0.8, 0, -0.4],
          [0.8, 0, -0.4],
          [-0.8, 0, 0.4],
          [0.8, 0, 0.4],
        ];
        teacherDeskLegPositions.forEach((pos) => {
          const leg = new THREE.Mesh(deskLegGeometry, deskLegMaterial);
          leg.position.set(4 + pos[0], 0.3, -5 + pos[2]);
          group.add(leg);
        });

        // Ø§Ù„Ù…Ø¹Ù„Ù… - Ø´ÙƒÙ„ Ø£ÙƒØ«Ø± ÙˆØ§Ù‚Ø¹ÙŠØ© ÙˆØªÙØµÙŠÙ„Ø§Ù‹
        const teacherBodyGeometry = new THREE.CylinderGeometry(
          0.3,
          0.35,
          1.2,
          16
        );
        const teacherBodyMaterial = new THREE.MeshLambertMaterial({
          color: 0x4169e1, // Ø£Ø²Ø±Ù‚ Ù…Ù„ÙƒÙŠ
        });
        const teacherBody = new THREE.Mesh(
          teacherBodyGeometry,
          teacherBodyMaterial
        );
        teacherBody.position.set(-1.5, 0.9, -5);
        group.add(teacherBody);

        const teacherHeadGeometry = new THREE.SphereGeometry(0.25, 16, 16);
        const teacherHeadMaterial = new THREE.MeshLambertMaterial({
          color: 0xffdbae,
        });
        const teacherHead = new THREE.Mesh(
          teacherHeadGeometry,
          teacherHeadMaterial
        );
        teacherHead.position.set(-1.5, 1.8, -5);
        group.add(teacherHead);

        // Ù†ÙˆØ§ÙØ° Ù…ØªØ¹Ø¯Ø¯Ø© Ù…Ø­Ø³Ù‘Ù†Ø©
        const windowGeometry = new THREE.PlaneGeometry(2.5, 2);
        const windowMaterial = new THREE.MeshLambertMaterial({
          color: 0x87ceeb,
          transparent: true,
          opacity: 0.6,
        });

        // Ø§Ù„Ù†Ø§ÙØ°Ø© Ø§Ù„Ø£ÙˆÙ„Ù‰
        const window1 = new THREE.Mesh(windowGeometry, windowMaterial);
        window1.position.set(7.5, 2.5, -2);
        window1.rotation.y = -Math.PI / 2;
        group.add(window1);

        // Ø§Ù„Ù†Ø§ÙØ°Ø© Ø§Ù„Ø«Ø§Ù†ÙŠØ©
        const window2 = new THREE.Mesh(windowGeometry, windowMaterial);
        window2.position.set(7.5, 2.5, 2);
        window2.rotation.y = -Math.PI / 2;
        group.add(window2);

        // Ø¥Ø·Ø§Ø±Ø§Øª Ø§Ù„Ù†ÙˆØ§ÙØ°
        const windowFrameGeometry = new THREE.BoxGeometry(2.6, 2.1, 0.08);
        const windowFrameMaterial = new THREE.MeshLambertMaterial({
          color: 0x8b4513,
        });

        const windowFrame1 = new THREE.Mesh(
          windowFrameGeometry,
          windowFrameMaterial
        );
        windowFrame1.position.set(7.9, 2.5, -2);
        windowFrame1.rotation.y = -Math.PI / 2;
        group.add(windowFrame1);

        const windowFrame2 = new THREE.Mesh(
          windowFrameGeometry,
          windowFrameMaterial
        );
        windowFrame2.position.set(7.9, 2.5, 2);
        windowFrame2.rotation.y = -Math.PI / 2;
        group.add(windowFrame2);

        // Ø®Ø²Ø§Ø¦Ù† Ù…ØªØ¹Ø¯Ø¯Ø©
        const cabinetGeometry = new THREE.BoxGeometry(1.2, 2.5, 0.5);
        const cabinetMaterial = new THREE.MeshLambertMaterial({
          color: 0x8b4513,
        });

        // Ø®Ø²Ø§Ù†Ø© Ø§Ù„ÙƒØªØ¨
        const cabinet1 = new THREE.Mesh(cabinetGeometry, cabinetMaterial);
        cabinet1.position.set(-7, 1.25, -6);
        group.add(cabinet1);

        // Ø®Ø²Ø§Ù†Ø© Ø§Ù„Ø£Ø¯ÙˆØ§Øª
        const cabinet2 = new THREE.Mesh(cabinetGeometry, cabinetMaterial);
        cabinet2.position.set(7, 1.25, -6);
        group.add(cabinet2);

        // Ø¥Ø¶Ø§ÙØ© Ø³Ø§Ø¹Ø© Ø§Ù„Ø­Ø§Ø¦Ø·
        const clockGeometry = new THREE.CylinderGeometry(0.3, 0.3, 0.1, 16);
        const clockMaterial = new THREE.MeshLambertMaterial({
          color: 0xffffff,
        });
        const clock = new THREE.Mesh(clockGeometry, clockMaterial);
        clock.position.set(3, 3.2, -6.8);
        clock.rotation.x = Math.PI / 2;
        group.add(clock);

        return group;
      }

      function createCafeteria() {
        const group = new THREE.Group();

        // Ø£Ø±Ø¶ÙŠØ© Ø§Ù„ÙƒØ§ÙÙŠØªÙŠØ±ÙŠØ§ Ø§Ù„Ù…Ø­Ø³Ù‘Ù†Ø© Ø¨Ù†Ù…Ø· Ù‡Ø§Ø¯Ø¦
        const floorGeometry = new THREE.PlaneGeometry(22, 18);
        const floorMaterial = new THREE.MeshLambertMaterial({
          color: 0xf5f5dc, // Ø¨ÙŠØ¬ ÙØ§ØªØ­ Ù‡Ø§Ø¯Ø¦
        });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        group.add(floor);

        // Ø®Ø·ÙˆØ· ØªÙˆØ¬ÙŠÙ‡ ÙÙŠ Ø§Ù„Ø£Ø±Ø¶ÙŠØ©
        const pathGeometry = new THREE.PlaneGeometry(22, 0.3);
        const pathMaterial = new THREE.MeshLambertMaterial({
          color: 0xe6e6fa, // Ø®Ø²Ø§Ù…ÙŠ ÙØ§ØªØ­
        });

        // Ù…Ù…Ø± Ù…Ø±ÙƒØ²ÙŠ
        const centralPath = new THREE.Mesh(pathGeometry, pathMaterial);
        centralPath.rotation.x = -Math.PI / 2;
        centralPath.position.set(0, 0.01, 0);
        group.add(centralPath);

        // Ù…Ù…Ø±Ø§Øª Ø¬Ø§Ù†Ø¨ÙŠØ©
        const sidePathGeometry = new THREE.PlaneGeometry(0.3, 18);
        const leftSidePath = new THREE.Mesh(sidePathGeometry, pathMaterial);
        leftSidePath.rotation.x = -Math.PI / 2;
        leftSidePath.position.set(-6, 0.01, 0);
        group.add(leftSidePath);

        const rightSidePath = new THREE.Mesh(sidePathGeometry, pathMaterial);
        rightSidePath.rotation.x = -Math.PI / 2;
        rightSidePath.position.set(6, 0.01, 0);
        group.add(rightSidePath);

        // Ø¬Ø¯Ø±Ø§Ù† Ø§Ù„ÙƒØ§ÙÙŠØªÙŠØ±ÙŠØ§ Ø¨Ø£Ù„ÙˆØ§Ù† Ù…Ù‡Ø¯Ø¦Ø©
        const wallMaterial = new THREE.MeshLambertMaterial({
          color: 0xfaf0e6, // ÙƒØ±ÙŠÙ…ÙŠ ÙØ§ØªØ­
        });

        // Ø§Ù„Ø¬Ø¯Ø§Ø± Ø§Ù„Ø®Ù„ÙÙŠ Ù…Ø¹ Ø´Ø±ÙŠØ· Ù…Ù„ÙˆÙ† Ù‡Ø§Ø¯Ø¦
        const backWallGeometry = new THREE.PlaneGeometry(22, 5);
        const backWall = new THREE.Mesh(backWallGeometry, wallMaterial);
        backWall.position.set(0, 2.5, -9);
        group.add(backWall);

        // Ø´Ø±ÙŠØ· Ø¯ÙŠÙƒÙˆØ±ÙŠ Ø¹Ù„Ù‰ Ø§Ù„Ø¬Ø¯Ø§Ø± Ø§Ù„Ø®Ù„ÙÙŠ
        const decorStripGeometry = new THREE.PlaneGeometry(22, 0.5);
        const decorStripMaterial = new THREE.MeshLambertMaterial({
          color: 0xd3d3d3, // Ø±Ù…Ø§Ø¯ÙŠ ÙØ§ØªØ­
        });
        const decorStrip = new THREE.Mesh(
          decorStripGeometry,
          decorStripMaterial
        );
        decorStrip.position.set(0, 3.5, -8.99);
        group.add(decorStrip);

        // Ø§Ù„Ø¬Ø¯Ø±Ø§Ù† Ø§Ù„Ø¬Ø§Ù†Ø¨ÙŠØ©
        const sideWallGeometry = new THREE.PlaneGeometry(18, 5);
        const leftWall = new THREE.Mesh(sideWallGeometry, wallMaterial);
        leftWall.position.set(-11, 2.5, 0);
        leftWall.rotation.y = Math.PI / 2;
        group.add(leftWall);

        const rightWall = new THREE.Mesh(sideWallGeometry, wallMaterial);
        rightWall.position.set(11, 2.5, 0);
        rightWall.rotation.y = -Math.PI / 2;
        group.add(rightWall);

        // Ø§Ù„Ø³Ù‚Ù Ù…Ø¹ ØªØµÙ…ÙŠÙ… Ù…Ø±ÙŠØ­
        const ceilingGeometry = new THREE.PlaneGeometry(22, 18);
        const ceilingMaterial = new THREE.MeshLambertMaterial({
          color: 0xf8f8ff, // Ø£Ø¨ÙŠØ¶ Ù…Ø¹ Ù„Ù…Ø³Ø© Ø²Ø±Ù‚Ø§Ø¡ ÙØ§ØªØ­Ø©
        });
        const ceiling = new THREE.Mesh(ceilingGeometry, ceilingMaterial);
        ceiling.rotation.x = Math.PI / 2;
        ceiling.position.set(0, 5, 0);
        group.add(ceiling);

        // Ø¥Ø¶Ø§Ø¡Ø© Ø§Ù„Ø³Ù‚Ù Ø§Ù„Ù…ÙˆØ²Ø¹Ø© Ø¨Ø´ÙƒÙ„ Ù…Ù†ØªØ¸Ù…
        const lightGeometry = new THREE.BoxGeometry(2.5, 0.1, 1.2);
        const lightMaterial = new THREE.MeshLambertMaterial({
          color: 0xffffcc,
          emissive: 0x444444,
        });

        // Ø´Ø¨ÙƒØ© Ø¥Ø¶Ø§Ø¡Ø© Ù…Ù†ØªØ¸Ù…Ø©
        for (let x = -2; x <= 2; x++) {
          for (let z = -1; z <= 1; z++) {
            const light = new THREE.Mesh(lightGeometry, lightMaterial);
            light.position.set(x * 4, 4.9, z * 3.5);
            group.add(light);
          }
        }

        // Ù…Ù†Ø·Ù‚Ø© Ø§Ù„Ø¬Ù„ÙˆØ³ Ø§Ù„Ù…Ø­Ø³Ù‘Ù†Ø© Ù…Ø¹ Ø·Ø§ÙˆÙ„Ø§Øª Ù…Ø³ØªØ¯ÙŠØ±Ø© ÙˆÙ…Ø±Ø¨Ø¹Ø©
        const roundTableGeometry = new THREE.CylinderGeometry(
          1.2,
          1.2,
          0.1,
          16
        );
        const squareTableGeometry = new THREE.BoxGeometry(2.2, 0.1, 2.2);
        const tableMaterial = new THREE.MeshLambertMaterial({
          color: 0xdaa520, // Ø°Ù‡Ø¨ÙŠ Ø¨Ø§Ù‡Øª
        });

        const tableLegGeometry = new THREE.CylinderGeometry(
          0.06,
          0.06,
          0.75,
          12
        );
        const tableLegMaterial = new THREE.MeshLambertMaterial({
          color: 0x696969, // Ø±Ù…Ø§Ø¯ÙŠ Ù…ØªÙˆØ³Ø·
        });

        // ÙƒØ±Ø§Ø³ÙŠ Ù…Ø­Ø³Ù‘Ù†Ø© Ù…Ø¹ ÙˆØ³Ø§Ø¦Ø¯
        const cushionSeatGeometry = new THREE.CylinderGeometry(
          0.25,
          0.25,
          0.08,
          16
        );
        const cushionBackGeometry = new THREE.BoxGeometry(0.5, 0.6, 0.08);
        const cushionMaterial = new THREE.MeshLambertMaterial({
          color: 0x87ceeb, // Ø£Ø²Ø±Ù‚ Ø³Ù…Ø§ÙˆÙŠ Ù‡Ø§Ø¯Ø¦
        });
        const chairFrameGeometry = new THREE.CylinderGeometry(
          0.04,
          0.04,
          0.45,
          12
        );
        const chairFrameMaterial = new THREE.MeshLambertMaterial({
          color: 0x708090, // Ø±Ù…Ø§Ø¯ÙŠ Ù…Ø§Ø¦Ù„ Ù„Ù„Ø£Ø²Ø±Ù‚
        });

        // Ù…Ù†Ø·Ù‚Ø© Ø§Ù„Ø·Ø§ÙˆÙ„Ø§Øª Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ© - ØªØ±ØªÙŠØ¨ Ù…Ù†Ø¸Ù…
        const seatingAreas = [
          // Ø·Ø§ÙˆÙ„Ø§Øª Ù…Ø³ØªØ¯ÙŠØ±Ø© ÙÙŠ Ø§Ù„ÙˆØ³Ø·
          { type: "round", x: -3.5, z: -2, chairs: 4 },
          { type: "round", x: 3.5, z: -2, chairs: 4 },
          { type: "round", x: -3.5, z: 2, chairs: 4 },
          { type: "round", x: 3.5, z: 2, chairs: 4 },

          // Ø·Ø§ÙˆÙ„Ø§Øª Ù…Ø±Ø¨Ø¹Ø© Ø¹Ù„Ù‰ Ø§Ù„Ø¬ÙˆØ§Ù†Ø¨
          { type: "square", x: -8, z: -3, chairs: 4 },
          { type: "square", x: 8, z: -3, chairs: 4 },
          { type: "square", x: -8, z: 3, chairs: 4 },
          { type: "square", x: 8, z: 3, chairs: 4 },

          // Ø·Ø§ÙˆÙ„Ø§Øª Ø¥Ø¶Ø§ÙÙŠØ© Ù„Ù„Ù…Ø³Ø§Ø­Ø©
          { type: "round", x: 0, z: 5, chairs: 6 },
          { type: "square", x: -3.5, z: -6, chairs: 4 },
          { type: "square", x: 3.5, z: -6, chairs: 4 },
        ];

        seatingAreas.forEach((area, areaIndex) => {
          let table,
            tableRadius = 1.2;

          if (area.type === "round") {
            table = new THREE.Mesh(roundTableGeometry, tableMaterial);
            tableRadius = 1.2;
          } else {
            table = new THREE.Mesh(squareTableGeometry, tableMaterial);
            tableRadius = 1.1;
          }

          table.position.set(area.x, 0.38, area.z);
          group.add(table);

          // Ø£Ø±Ø¬Ù„ Ø§Ù„Ø·Ø§ÙˆÙ„Ø©
          const legPositions =
            area.type === "round"
              ? [
                  [-0.8, 0, -0.8],
                  [0.8, 0, -0.8],
                  [-0.8, 0, 0.8],
                  [0.8, 0, 0.8],
                ]
              : [
                  [-0.9, 0, -0.9],
                  [0.9, 0, -0.9],
                  [-0.9, 0, 0.9],
                  [0.9, 0, 0.9],
                ];

          legPositions.forEach((pos) => {
            const leg = new THREE.Mesh(tableLegGeometry, tableLegMaterial);
            leg.position.set(area.x + pos[0], 0.2, area.z + pos[2]);
            group.add(leg);
          });

          // ØªØ±ØªÙŠØ¨ Ø§Ù„ÙƒØ±Ø§Ø³ÙŠ Ø­ÙˆÙ„ Ø§Ù„Ø·Ø§ÙˆÙ„Ø©
          const angleStep = (Math.PI * 2) / area.chairs;
          for (let i = 0; i < area.chairs; i++) {
            const angle = i * angleStep;
            const chairX = area.x + Math.cos(angle) * (tableRadius + 0.7);
            const chairZ = area.z + Math.sin(angle) * (tableRadius + 0.7);

            // Ù…Ù‚Ø¹Ø¯ Ø§Ù„ÙƒØ±Ø³ÙŠ
            const chairSeat = new THREE.Mesh(
              cushionSeatGeometry,
              cushionMaterial
            );
            chairSeat.position.set(chairX, 0.23, chairZ);
            group.add(chairSeat);

            // Ø¸Ù‡Ø± Ø§Ù„ÙƒØ±Ø³ÙŠ
            const chairBack = new THREE.Mesh(
              cushionBackGeometry,
              cushionMaterial
            );
            chairBack.position.set(chairX, 0.6, chairZ);
            chairBack.rotation.y = angle + Math.PI;
            group.add(chairBack);

            // Ø£Ø±Ø¬Ù„ Ø§Ù„ÙƒØ±Ø³ÙŠ
            const chairLegPositions = [
              [-0.15, 0, -0.15],
              [0.15, 0, -0.15],
              [-0.15, 0, 0.15],
              [0.15, 0, 0.15],
            ];
            chairLegPositions.forEach((legPos) => {
              const chairLeg = new THREE.Mesh(
                chairFrameGeometry,
                chairFrameMaterial
              );
              chairLeg.position.set(
                chairX + legPos[0],
                0.115,
                chairZ + legPos[2]
              );
              group.add(chairLeg);
            });

            // Ø¥Ø¶Ø§ÙØ© Ø¹Ù†Ø§ØµØ± Ø¹Ù„Ù‰ Ø§Ù„Ø·Ø§ÙˆÙ„Ø§Øª Ø¨Ø´ÙƒÙ„ Ø¹Ø´ÙˆØ§Ø¦ÙŠ
            if (Math.random() > 0.4) {
              // ØµÙˆØ§Ù†ÙŠ Ø·Ø¹Ø§Ù… Ù…ØªÙ†ÙˆØ¹Ø©
              const trayGeometry = new THREE.CylinderGeometry(
                0.3,
                0.3,
                0.04,
                12
              );
              const trayColors = [0xf0e68c, 0xdda0dd, 0x98fb98, 0xffd4b3];
              const trayMaterial = new THREE.MeshLambertMaterial({
                color:
                  trayColors[Math.floor(Math.random() * trayColors.length)],
              });
              const tray = new THREE.Mesh(trayGeometry, trayMaterial);
              tray.position.set(
                area.x + (Math.random() - 0.5) * 0.8,
                0.45,
                area.z + (Math.random() - 0.5) * 0.8
              );
              group.add(tray);
            }

            // Ø£ÙƒÙˆØ§Ø¨ ÙˆØ²Ø¬Ø§Ø¬Ø§Øª Ù…ØªÙ†ÙˆØ¹Ø©
            if (Math.random() > 0.5) {
              const drinkHeight = 0.12 + Math.random() * 0.08;
              const drinkGeometry = new THREE.CylinderGeometry(
                0.05,
                0.05,
                drinkHeight,
                8
              );
              const drinkColors = [
                0x4169e1, 0x32cd32, 0xff6347, 0xffd700, 0x9370db,
              ];
              const drinkMaterial = new THREE.MeshLambertMaterial({
                color:
                  drinkColors[Math.floor(Math.random() * drinkColors.length)],
              });
              const drink = new THREE.Mesh(drinkGeometry, drinkMaterial);
              drink.position.set(
                area.x + (Math.random() - 0.5) * 1.0,
                0.45 + drinkHeight / 2,
                area.z + (Math.random() - 0.5) * 1.0
              );
              group.add(drink);
            }
          }
        });

        // Ù…Ù†Ø·Ù‚Ø© Ø§Ù„ØªÙ‚Ø¯ÙŠÙ… Ø§Ù„Ù…Ø­Ø³Ù‘Ù†Ø© ÙˆØ§Ù„Ù…ØªØ·ÙˆØ±Ø©
        const mainCounterGeometry = new THREE.BoxGeometry(12, 0.9, 1.8);
        const counterMaterial = new THREE.MeshLambertMaterial({
          color: 0xf5deb3, // Ù‚Ù…Ø­ ÙØ§ØªØ­
        });
        const mainCounter = new THREE.Mesh(
          mainCounterGeometry,
          counterMaterial
        );
        mainCounter.position.set(0, 0.45, -7.5);
        group.add(mainCounter);

        // Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ù…Ù†Ø¶Ø¯Ø© Ø§Ù„Ù…ØªÙŠÙ†Ø©
        const counterBaseGeometry = new THREE.BoxGeometry(12, 0.3, 1.8);
        const counterBaseMaterial = new THREE.MeshLambertMaterial({
          color: 0xd2b48c, // ØªØ§Ù†
        });
        const counterBase = new THREE.Mesh(
          counterBaseGeometry,
          counterBaseMaterial
        );
        counterBase.position.set(0, 0.15, -7.5);
        group.add(counterBase);

        // ÙˆØ§Ø¬Ù‡Ø© Ø²Ø¬Ø§Ø¬ÙŠØ© Ù„Ù„Ø­Ù…Ø§ÙŠØ© - Ù…ØªØ¹Ø¯Ø¯Ø© Ø§Ù„Ø£Ù‚Ø³Ø§Ù…
        for (let i = -2; i <= 2; i++) {
          const glassGeometry = new THREE.BoxGeometry(2.2, 0.9, 0.08);
          const glassMaterial = new THREE.MeshLambertMaterial({
            color: 0xb0e0e6, // Ø£Ø²Ø±Ù‚ Ø¨Ø§ÙˆØ¯Ø± ÙØ§ØªØ­
            transparent: true,
            opacity: 0.4,
          });
          const glass = new THREE.Mesh(glassGeometry, glassMaterial);
          glass.position.set(i * 2.4, 1.35, -6.6);
          group.add(glass);

          // Ø¥Ø·Ø§Ø± Ø§Ù„Ø²Ø¬Ø§Ø¬
          const frameGeometry = new THREE.BoxGeometry(2.3, 1.0, 0.05);
          const frameMaterial = new THREE.MeshLambertMaterial({
            color: 0x696969,
          });
          const frame = new THREE.Mesh(frameGeometry, frameMaterial);
          frame.position.set(i * 2.4, 1.35, -6.55);
          group.add(frame);
        }

        // Ù…Ù†Ø·Ù‚Ø© Ø¹Ø±Ø¶ Ø§Ù„Ø·Ø¹Ø§Ù… Ø§Ù„Ù…ØªÙ†ÙˆØ¹Ø©
        const foodDisplays = [
          { name: "salad", color: 0x32cd32, x: -4.8, shape: "round" },
          { name: "main", color: 0xff6347, x: -2.4, shape: "rect" },
          { name: "soup", color: 0xffd700, x: 0, shape: "round" },
          { name: "dessert", color: 0xffb6c1, x: 2.4, shape: "round" },
          { name: "fruits", color: 0xff4500, x: 4.8, shape: "rect" },
        ];

        foodDisplays.forEach((display) => {
          // Ø·Ø¨Ù‚ Ø§Ù„Ø¹Ø±Ø¶
          const plateGeometry =
            display.shape === "round"
              ? new THREE.CylinderGeometry(0.35, 0.35, 0.05, 16)
              : new THREE.BoxGeometry(0.7, 0.05, 0.5);
          const plateMaterial = new THREE.MeshLambertMaterial({
            color: 0xffffff,
          });
          const plate = new THREE.Mesh(plateGeometry, plateMaterial);
          plate.position.set(display.x, 0.92, -7.2);
          group.add(plate);

          // Ø§Ù„Ø·Ø¹Ø§Ù… Ø¹Ù„Ù‰ Ø§Ù„Ø·Ø¨Ù‚
          const foodGeometry =
            display.shape === "round"
              ? new THREE.SphereGeometry(0.15, 8, 8)
              : new THREE.BoxGeometry(0.25, 0.1, 0.2);
          const foodMaterial = new THREE.MeshLambertMaterial({
            color: display.color,
          });

          // Ø¹Ø¯Ø© Ù‚Ø·Ø¹ Ø·Ø¹Ø§Ù… Ø¹Ù„Ù‰ ÙƒÙ„ Ø·Ø¨Ù‚
          for (let j = 0; j < 3; j++) {
            const food = new THREE.Mesh(foodGeometry, foodMaterial);
            const offsetX = (Math.random() - 0.5) * 0.4;
            const offsetZ = (Math.random() - 0.5) * 0.3;
            food.position.set(display.x + offsetX, 0.98, -7.2 + offsetZ);
            group.add(food);
          }

          // Ù„Ø§ÙØªØ© ØµØºÙŠØ±Ø© Ù„Ù„Ø·Ø¹Ø§Ù…
          const labelGeometry = new THREE.BoxGeometry(0.3, 0.1, 0.02);
          const labelMaterial = new THREE.MeshLambertMaterial({
            color: 0xfffacd,
          });
          const label = new THREE.Mesh(labelGeometry, labelMaterial);
          label.position.set(display.x, 1.1, -6.8);
          group.add(label);
        });

        // Ù…Ù†Ø·Ù‚Ø© Ø§Ù„Ù…Ø´Ø±ÙˆØ¨Ø§Øª
        const drinkStationGeometry = new THREE.BoxGeometry(2, 1.2, 0.8);
        const drinkStationMaterial = new THREE.MeshLambertMaterial({
          color: 0xe0e0e0,
        });
        const drinkStation = new THREE.Mesh(
          drinkStationGeometry,
          drinkStationMaterial
        );
        drinkStation.position.set(-8, 0.6, -7);
        group.add(drinkStation);

        // Ù…ÙˆØ²Ø¹Ø§Øª Ø§Ù„Ù…Ø´Ø±ÙˆØ¨Ø§Øª
        for (let i = 0; i < 3; i++) {
          const dispenserGeometry = new THREE.CylinderGeometry(
            0.15,
            0.15,
            0.6,
            12
          );
          const dispenserColors = [0xff6347, 0x32cd32, 0x4169e1];
          const dispenserMaterial = new THREE.MeshLambertMaterial({
            color: dispenserColors[i],
            transparent: true,
            opacity: 0.7,
          });
          const dispenser = new THREE.Mesh(
            dispenserGeometry,
            dispenserMaterial
          );
          dispenser.position.set(-8.5 + i * 0.5, 1.5, -7);
          group.add(dispenser);
        }

        // Ù…Ø§ÙƒÙŠÙ†Ø© ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ù†Ù‚Ø¯ÙŠØ©
        const cashRegisterGeometry = new THREE.BoxGeometry(0.8, 0.4, 0.6);
        const cashRegisterMaterial = new THREE.MeshLambertMaterial({
          color: 0x2f4f4f,
        });
        const cashRegister = new THREE.Mesh(
          cashRegisterGeometry,
          cashRegisterMaterial
        );
        cashRegister.position.set(6, 1.1, -7);
        group.add(cashRegister);

        // Ø´Ø§Ø´Ø© Ø§Ù„Ù…Ø§ÙƒÙŠÙ†Ø©
        const screenGeometry = new THREE.BoxGeometry(0.3, 0.2, 0.05);
        const screenMaterial = new THREE.MeshLambertMaterial({
          color: 0x000000,
          emissive: 0x003300,
        });
        const screen = new THREE.Mesh(screenGeometry, screenMaterial);
        screen.position.set(6, 1.3, -6.65);
        group.add(screen);

        // Ù…Ù†Ø·Ù‚Ø© Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ø·Ø¹Ø§Ù… Ø®Ù„Ù Ø§Ù„Ù…Ù†Ø¶Ø¯Ø©
        const kitchenCounterGeometry = new THREE.BoxGeometry(10, 0.8, 1.5);
        const kitchenCounterMaterial = new THREE.MeshLambertMaterial({
          color: 0xc0c0c0,
        });
        const kitchenCounter = new THREE.Mesh(
          kitchenCounterGeometry,
          kitchenCounterMaterial
        );
        kitchenCounter.position.set(0, 0.4, -8.8);
        group.add(kitchenCounter);

        // Ù…ÙˆØ¸ÙÙˆ Ø§Ù„ÙƒØ§ÙÙŠØªÙŠØ±ÙŠØ§ Ø§Ù„Ù…Ø­Ø³Ù‘Ù†ÙˆÙ†
        const workerBodyGeometry = new THREE.CylinderGeometry(
          0.3,
          0.35,
          1.3,
          16
        );
        const workerUniformMaterial = new THREE.MeshLambertMaterial({
          color: 0xf0f8ff, // Ø£Ø¨ÙŠØ¶ Ù…Ø¹ Ù„Ù…Ø³Ø© Ø²Ø±Ù‚Ø§Ø¡ ÙØ§ØªØ­Ø©
        });
        const workerApronMaterial = new THREE.MeshLambertMaterial({
          color: 0xe6e6fa, // Ø®Ø²Ø§Ù…ÙŠ ÙØ§ØªØ­
        });

        // Ø§Ù„Ù…Ø¯ÙŠØ± Ø£Ùˆ Ø§Ù„Ø·Ø§Ù‡ÙŠ Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ
        const chefBody = new THREE.Mesh(
          workerBodyGeometry,
          workerUniformMaterial
        );
        chefBody.position.set(0, 0.9, -8.5);
        group.add(chefBody);

        const chefHeadGeometry = new THREE.SphereGeometry(0.22, 16, 16);
        const workerHeadMaterial = new THREE.MeshLambertMaterial({
          color: 0xfdbcb4,
        });
        const chefHead = new THREE.Mesh(chefHeadGeometry, workerHeadMaterial);
        chefHead.position.set(0, 1.7, -8.5);
        group.add(chefHead);

        // Ù‚Ø¨Ø¹Ø© Ø§Ù„Ø·Ø§Ù‡ÙŠ
        const chefHatGeometry = new THREE.CylinderGeometry(0.18, 0.22, 0.4, 16);
        const chefHatMaterial = new THREE.MeshLambertMaterial({
          color: 0xffffff,
        });
        const chefHat = new THREE.Mesh(chefHatGeometry, chefHatMaterial);
        chefHat.position.set(0, 2.1, -8.5);
        group.add(chefHat);

        // Ù…Ø¦Ø²Ø± Ø§Ù„Ø·Ø§Ù‡ÙŠ
        const apronGeometry = new THREE.BoxGeometry(0.5, 0.8, 0.05);
        const chefApron = new THREE.Mesh(apronGeometry, workerApronMaterial);
        chefApron.position.set(0, 1.1, -8.15);
        group.add(chefApron);

        // Ø¹Ø§Ù…Ù„ Ø§Ù„ØªÙ‚Ø¯ÙŠÙ… Ø§Ù„Ø£ÙˆÙ„
        const server1Body = new THREE.Mesh(
          workerBodyGeometry,
          workerUniformMaterial
        );
        server1Body.position.set(-3.5, 0.9, -8.2);
        group.add(server1Body);

        const server1Head = new THREE.Mesh(
          chefHeadGeometry,
          workerHeadMaterial
        );
        server1Head.position.set(-3.5, 1.7, -8.2);
        group.add(server1Head);

        // Ù‚Ø¨Ø¹Ø© Ø§Ù„Ø¹Ø§Ù…Ù„
        const workerCapGeometry = new THREE.CylinderGeometry(0.2, 0.2, 0.1, 16);
        const workerCapMaterial = new THREE.MeshLambertMaterial({
          color: 0xd3d3d3,
        });
        const server1Cap = new THREE.Mesh(workerCapGeometry, workerCapMaterial);
        server1Cap.position.set(-3.5, 1.9, -8.2);
        group.add(server1Cap);

        // Ø¹Ø§Ù…Ù„ Ø§Ù„ØªÙ‚Ø¯ÙŠÙ… Ø§Ù„Ø«Ø§Ù†ÙŠ
        const server2Body = new THREE.Mesh(
          workerBodyGeometry,
          workerUniformMaterial
        );
        server2Body.position.set(3.5, 0.9, -8.2);
        group.add(server2Body);

        const server2Head = new THREE.Mesh(
          chefHeadGeometry,
          workerHeadMaterial
        );
        server2Head.position.set(3.5, 1.7, -8.2);
        group.add(server2Head);

        const server2Cap = new THREE.Mesh(workerCapGeometry, workerCapMaterial);
        server2Cap.position.set(3.5, 1.9, -8.2);
        group.add(server2Cap);

        // Ø¹Ø§Ù…Ù„ Ø§Ù„Ù†Ø¸Ø§ÙØ©
        const cleanerBody = new THREE.Mesh(
          workerBodyGeometry,
          workerUniformMaterial
        );
        cleanerBody.position.set(9, 0.9, -3);
        group.add(cleanerBody);

        const cleanerHead = new THREE.Mesh(
          chefHeadGeometry,
          workerHeadMaterial
        );
        cleanerHead.position.set(9, 1.7, -3);
        group.add(cleanerHead);

        // Ø¹Ø±Ø¨Ø© Ø§Ù„ØªÙ†Ø¸ÙŠÙ
        const cartGeometry = new THREE.BoxGeometry(0.8, 0.6, 0.5);
        const cartMaterial = new THREE.MeshLambertMaterial({
          color: 0x808080,
        });
        const cleaningCart = new THREE.Mesh(cartGeometry, cartMaterial);
        cleaningCart.position.set(9.5, 0.3, -2.5);
        group.add(cleaningCart);

        // Ø¯Ù„Ùˆ Ø§Ù„ØªÙ†Ø¸ÙŠÙ
        const bucketGeometry = new THREE.CylinderGeometry(0.15, 0.12, 0.25, 12);
        const bucketMaterial = new THREE.MeshLambertMaterial({
          color: 0x4169e1,
        });
        const bucket = new THREE.Mesh(bucketGeometry, bucketMaterial);
        bucket.position.set(9.3, 0.7, -2.3);
        group.add(bucket);

        // Ø«Ù„Ø§Ø¬Ø© Ø§Ù„Ø¹Ø±Ø¶ Ø§Ù„Ù…Ø­Ø³Ù‘Ù†Ø©
        const displayFridgeGeometry = new THREE.BoxGeometry(2, 2.4, 1);
        const fridgeMaterial = new THREE.MeshLambertMaterial({
          color: 0xf5f5f5, // ÙØ¶ÙŠ ÙØ§ØªØ­
        });
        const displayFridge = new THREE.Mesh(
          displayFridgeGeometry,
          fridgeMaterial
        );
        displayFridge.position.set(-9, 1.2, -7.5);
        group.add(displayFridge);

        // Ø£Ø¨ÙˆØ§Ø¨ Ø§Ù„Ø«Ù„Ø§Ø¬Ø© Ø§Ù„Ø´ÙØ§ÙØ© - Ù…Ù‚Ø³Ù…Ø©
        for (let i = 0; i < 2; i++) {
          const fridgeDoorGeometry = new THREE.BoxGeometry(0.95, 2.2, 0.08);
          const fridgeDoorMaterial = new THREE.MeshLambertMaterial({
            color: 0xb0e0e6,
            transparent: true,
            opacity: 0.5,
          });
          const fridgeDoor = new THREE.Mesh(
            fridgeDoorGeometry,
            fridgeDoorMaterial
          );
          fridgeDoor.position.set(-9.4 + i * 1, 1.2, -6.9);
          group.add(fridgeDoor);

          // Ù…Ù‚Ø§Ø¨Ø¶ Ø§Ù„Ø£Ø¨ÙˆØ§Ø¨
          const handleGeometry = new THREE.BoxGeometry(0.05, 0.3, 0.08);
          const handleMaterial = new THREE.MeshLambertMaterial({
            color: 0x696969,
          });
          const handle = new THREE.Mesh(handleGeometry, handleMaterial);
          handle.position.set(
            -9.4 + i * 1 + (i === 0 ? 0.4 : -0.4),
            1.2,
            -6.85
          );
          group.add(handle);
        }

        // Ø±ÙÙˆÙ Ø¯Ø§Ø®Ù„ Ø§Ù„Ø«Ù„Ø§Ø¬Ø©
        for (let shelf = 0; shelf < 3; shelf++) {
          const shelfGeometry = new THREE.BoxGeometry(1.8, 0.03, 0.8);
          const shelfMaterial = new THREE.MeshLambertMaterial({
            color: 0xffffff,
          });
          const fridgeShelf = new THREE.Mesh(shelfGeometry, shelfMaterial);
          fridgeShelf.position.set(-9, 0.4 + shelf * 0.6, -7.3);
          group.add(fridgeShelf);

          // Ù…Ù†ØªØ¬Ø§Øª Ø¹Ù„Ù‰ Ø§Ù„Ø±ÙÙˆÙ
          for (let item = 0; item < 4; item++) {
            const itemGeometry = new THREE.BoxGeometry(0.15, 0.25, 0.1);
            const itemColors = [0xff6347, 0x32cd32, 0x4169e1, 0xffd700];
            const itemMaterial = new THREE.MeshLambertMaterial({
              color: itemColors[item],
            });
            const fridgeItem = new THREE.Mesh(itemGeometry, itemMaterial);
            fridgeItem.position.set(
              -9.6 + item * 0.4,
              0.55 + shelf * 0.6,
              -7.3
            );
            group.add(fridgeItem);
          }
        }

        // Ø¢Ù„Ø© Ø§Ù„Ù…Ø´Ø±ÙˆØ¨Ø§Øª Ø§Ù„Ù…Ø­Ø³Ù‘Ù†Ø©
        const vendingMachineGeometry = new THREE.BoxGeometry(1.5, 2.5, 0.8);
        const vendingMachineMaterial = new THREE.MeshLambertMaterial({
          color: 0x8b0000, // Ø£Ø­Ù…Ø± Ø¯Ø§ÙƒÙ†
        });
        const vendingMachine = new THREE.Mesh(
          vendingMachineGeometry,
          vendingMachineMaterial
        );
        vendingMachine.position.set(9, 1.25, -7.5);
        group.add(vendingMachine);

        // Ø´Ø§Ø´Ø© Ø¢Ù„Ø© Ø§Ù„Ù…Ø´Ø±ÙˆØ¨Ø§Øª
        const vendingScreenGeometry = new THREE.BoxGeometry(0.8, 0.6, 0.05);
        const vendingScreenMaterial = new THREE.MeshLambertMaterial({
          color: 0x000000,
          emissive: 0x001100,
        });
        const vendingScreen = new THREE.Mesh(
          vendingScreenGeometry,
          vendingScreenMaterial
        );
        vendingScreen.position.set(9, 1.8, -7.05);
        group.add(vendingScreen);

        // Ø£Ø²Ø±Ø§Ø± Ø§Ù„Ø§Ø®ØªÙŠØ§Ø±
        for (let row = 0; row < 2; row++) {
          for (let col = 0; col < 3; col++) {
            const buttonGeometry = new THREE.CylinderGeometry(
              0.06,
              0.06,
              0.03,
              12
            );
            const buttonMaterial = new THREE.MeshLambertMaterial({
              color: 0xffffff,
            });
            const button = new THREE.Mesh(buttonGeometry, buttonMaterial);
            button.position.set(8.7 + col * 0.2, 1.2 - row * 0.3, -7.05);
            button.rotation.x = Math.PI / 2;
            group.add(button);
          }
        }

        // ÙØªØ­Ø© Ø§Ø³ØªÙ„Ø§Ù… Ø§Ù„Ù…Ø´Ø±ÙˆØ¨Ø§Øª
        const dispenserSlotGeometry = new THREE.BoxGeometry(0.4, 0.15, 0.1);
        const dispenserSlotMaterial = new THREE.MeshLambertMaterial({
          color: 0x333333,
        });
        const dispenserSlot = new THREE.Mesh(
          dispenserSlotGeometry,
          dispenserSlotMaterial
        );
        dispenserSlot.position.set(9, 0.4, -7.05);
        group.add(dispenserSlot);

        // Ù…ÙŠÙƒØ±ÙˆÙˆÙŠÙ ÙÙŠ Ù…Ù†Ø·Ù‚Ø© Ø§Ù„Ø®Ø¯Ù…Ø©
        const microwaveGeometry = new THREE.BoxGeometry(0.8, 0.5, 0.6);
        const microwaveMaterial = new THREE.MeshLambertMaterial({
          color: 0xc0c0c0,
        });
        const microwave = new THREE.Mesh(microwaveGeometry, microwaveMaterial);
        microwave.position.set(-6, 1.6, -8.5);
        group.add(microwave);

        // Ø¨Ø§Ø¨ Ø§Ù„Ù…ÙŠÙƒØ±ÙˆÙˆÙŠÙ
        const microwaveDoorGeometry = new THREE.BoxGeometry(0.75, 0.45, 0.05);
        const microwaveDoorMaterial = new THREE.MeshLambertMaterial({
          color: 0x888888,
        });
        const microwaveDoor = new THREE.Mesh(
          microwaveDoorGeometry,
          microwaveDoorMaterial
        );
        microwaveDoor.position.set(-6, 1.6, -8.15);
        group.add(microwaveDoor);

        // Ø¢Ù„Ø© ØµÙ†Ø¹ Ø§Ù„Ù‚Ù‡ÙˆØ©
        const coffeeMachineGeometry = new THREE.BoxGeometry(0.6, 0.8, 0.5);
        const coffeeMachineMaterial = new THREE.MeshLambertMaterial({
          color: 0x2f4f4f,
        });
        const coffeeMachine = new THREE.Mesh(
          coffeeMachineGeometry,
          coffeeMachineMaterial
        );
        coffeeMachine.position.set(6, 1.2, -8.5);
        group.add(coffeeMachine);

        // Ø®Ø²Ø§Ù† Ø§Ù„Ù‚Ù‡ÙˆØ©
        const coffeeTankGeometry = new THREE.CylinderGeometry(
          0.2,
          0.2,
          0.4,
          12
        );
        const coffeeTankMaterial = new THREE.MeshLambertMaterial({
          color: 0x8b4513,
          transparent: true,
          opacity: 0.7,
        });
        const coffeeTank = new THREE.Mesh(
          coffeeTankGeometry,
          coffeeTankMaterial
        );
        coffeeTank.position.set(6, 1.6, -8.5);
        group.add(coffeeTank);

        // Ù†ÙˆØ§ÙØ° Ø§Ù„ÙƒØ§ÙÙŠØªÙŠØ±ÙŠØ§ Ø§Ù„Ù…Ø­Ø³Ù‘Ù†Ø© Ù…Ø¹ Ø³ØªØ§Ø¦Ø±
        const cafeWindowGeometry = new THREE.PlaneGeometry(4, 3);
        const cafeWindowMaterial = new THREE.MeshLambertMaterial({
          color: 0xb0e0e6,
          transparent: true,
          opacity: 0.7,
        });

        // Ù†Ø§ÙØ°Ø© ÙŠØ³Ø§Ø± Ù…Ø¹ Ù…Ù†Ø¸Ø± Ø®Ø§Ø±Ø¬ÙŠ
        const leftWindow = new THREE.Mesh(
          cafeWindowGeometry,
          cafeWindowMaterial
        );
        leftWindow.position.set(-10.5, 2.8, 2);
        leftWindow.rotation.y = Math.PI / 2;
        group.add(leftWindow);

        // Ù†Ø§ÙØ°Ø© ÙŠÙ…ÙŠÙ†
        const rightWindow = new THREE.Mesh(
          cafeWindowGeometry,
          cafeWindowMaterial
        );
        rightWindow.position.set(10.5, 2.8, 2);
        rightWindow.rotation.y = -Math.PI / 2;
        group.add(rightWindow);

        // Ø¥Ø·Ø§Ø±Ø§Øª Ø§Ù„Ù†ÙˆØ§ÙØ° Ø§Ù„Ù…Ø­Ø³Ù‘Ù†Ø©
        const cafeFrameGeometry = new THREE.BoxGeometry(4.2, 3.2, 0.1);
        const cafeFrameMaterial = new THREE.MeshLambertMaterial({
          color: 0x8b4513,
        });

        const leftFrame = new THREE.Mesh(cafeFrameGeometry, cafeFrameMaterial);
        leftFrame.position.set(-10.9, 2.8, 2);
        leftFrame.rotation.y = Math.PI / 2;
        group.add(leftFrame);

        const rightFrame = new THREE.Mesh(cafeFrameGeometry, cafeFrameMaterial);
        rightFrame.position.set(10.9, 2.8, 2);
        rightFrame.rotation.y = -Math.PI / 2;
        group.add(rightFrame);

        // Ø³ØªØ§Ø¦Ø± Ø¬Ù…ÙŠÙ„Ø© ÙˆÙ‡Ø§Ø¯Ø¦Ø©
        const curtainGeometry = new THREE.PlaneGeometry(1.8, 2.8);
        const curtainMaterial = new THREE.MeshLambertMaterial({
          color: 0xf0e68c, // Ø®Ø§ÙƒÙŠ ÙØ§ØªØ­
          transparent: true,
          opacity: 0.6,
        });

        // Ø³ØªØ§Ø¦Ø± Ø§Ù„Ù†Ø§ÙØ°Ø© Ø§Ù„ÙŠØ³Ø±Ù‰
        const leftCurtain1 = new THREE.Mesh(curtainGeometry, curtainMaterial);
        leftCurtain1.position.set(-10.45, 2.8, 0.9);
        leftCurtain1.rotation.y = Math.PI / 2;
        group.add(leftCurtain1);

        const leftCurtain2 = new THREE.Mesh(curtainGeometry, curtainMaterial);
        leftCurtain2.position.set(-10.45, 2.8, 3.1);
        leftCurtain2.rotation.y = Math.PI / 2;
        group.add(leftCurtain2);

        // Ø³ØªØ§Ø¦Ø± Ø§Ù„Ù†Ø§ÙØ°Ø© Ø§Ù„ÙŠÙ…Ù†Ù‰
        const rightCurtain1 = new THREE.Mesh(curtainGeometry, curtainMaterial);
        rightCurtain1.position.set(10.45, 2.8, 0.9);
        rightCurtain1.rotation.y = -Math.PI / 2;
        group.add(rightCurtain1);

        const rightCurtain2 = new THREE.Mesh(curtainGeometry, curtainMaterial);
        rightCurtain2.position.set(10.45, 2.8, 3.1);
        rightCurtain2.rotation.y = -Math.PI / 2;
        group.add(rightCurtain2);

        // Ù„ÙˆØ­Ø© Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø·Ø¹Ø§Ù… Ø§Ù„Ù…Ø­Ø³Ù‘Ù†Ø©
        const menuBoardGeometry = new THREE.BoxGeometry(3.5, 2.5, 0.12);
        const menuBoardMaterial = new THREE.MeshLambertMaterial({
          color: 0x2f4f4f, // Ø±Ù…Ø§Ø¯ÙŠ Ø¯Ø§ÙƒÙ† Ù…Ø®Ø¶Ø±
        });
        const menuBoard = new THREE.Mesh(menuBoardGeometry, menuBoardMaterial);
        menuBoard.position.set(-6, 3, -8.9);
        group.add(menuBoard);

        // Ø¥Ø·Ø§Ø± Ø§Ù„Ù„ÙˆØ­Ø©
        const menuFrameGeometry = new THREE.BoxGeometry(3.7, 2.7, 0.08);
        const menuFrameMaterial = new THREE.MeshLambertMaterial({
          color: 0x8b4513,
        });
        const menuFrame = new THREE.Mesh(menuFrameGeometry, menuFrameMaterial);
        menuFrame.position.set(-6, 3, -8.95);
        group.add(menuFrame);

        // Ù†Øµ Ø¹Ù„Ù‰ Ø§Ù„Ù„ÙˆØ­Ø© (Ù…Ø­Ø§ÙƒØ§Ø©)
        for (let i = 0; i < 5; i++) {
          const textLineGeometry = new THREE.BoxGeometry(2.8, 0.1, 0.02);
          const textLineMaterial = new THREE.MeshLambertMaterial({
            color: 0xffffff,
          });
          const textLine = new THREE.Mesh(textLineGeometry, textLineMaterial);
          textLine.position.set(-6, 3.8 - i * 0.3, -8.85);
          group.add(textLine);
        }

        // Ø³Ø§Ø¹Ø© Ø§Ù„ÙƒØ§ÙÙŠØªÙŠØ±ÙŠØ§ Ø§Ù„Ù…Ø­Ø³Ù‘Ù†Ø©
        const cafeClockGeometry = new THREE.CylinderGeometry(0.4, 0.4, 0.1, 32);
        const cafeClockMaterial = new THREE.MeshLambertMaterial({
          color: 0xffffff,
        });
        const cafeClock = new THREE.Mesh(cafeClockGeometry, cafeClockMaterial);
        cafeClock.position.set(6, 4.2, -8.8);
        cafeClock.rotation.x = Math.PI / 2;
        group.add(cafeClock);

        // ÙˆØ¬Ù‡ Ø§Ù„Ø³Ø§Ø¹Ø©
        const clockFaceGeometry = new THREE.CylinderGeometry(
          0.35,
          0.35,
          0.02,
          32
        );
        const clockFaceMaterial = new THREE.MeshLambertMaterial({
          color: 0xf8f8ff,
        });
        const clockFace = new THREE.Mesh(clockFaceGeometry, clockFaceMaterial);
        clockFace.position.set(6, 4.25, -8.8);
        clockFace.rotation.x = Math.PI / 2;
        group.add(clockFace);

        // Ø¹Ù‚Ø§Ø±Ø¨ Ø§Ù„Ø³Ø§Ø¹Ø©
        const hourHandGeometry = new THREE.BoxGeometry(0.02, 0.2, 0.01);
        const minuteHandGeometry = new THREE.BoxGeometry(0.015, 0.3, 0.01);
        const handMaterial = new THREE.MeshLambertMaterial({
          color: 0x000000,
        });

        const hourHand = new THREE.Mesh(hourHandGeometry, handMaterial);
        hourHand.position.set(6, 4.27, -8.8);
        hourHand.rotation.x = Math.PI / 2;
        hourHand.rotation.z = Math.PI / 4;
        group.add(hourHand);

        const minuteHand = new THREE.Mesh(minuteHandGeometry, handMaterial);
        minuteHand.position.set(6, 4.27, -8.8);
        minuteHand.rotation.x = Math.PI / 2;
        minuteHand.rotation.z = Math.PI / 6;
        group.add(minuteHand);

        // Ù†Ø¨Ø§ØªØ§Øª Ø¯ÙŠÙƒÙˆØ±ÙŠØ© Ù…ØªÙ†ÙˆØ¹Ø© ÙˆÙ…Ù‡Ø¯Ø¦Ø©
        const largePotGeometry = new THREE.CylinderGeometry(0.4, 0.35, 0.5, 16);
        const smallPotGeometry = new THREE.CylinderGeometry(0.25, 0.2, 0.3, 12);
        const potMaterial = new THREE.MeshLambertMaterial({
          color: 0x8b4513, // Ø¨Ù†ÙŠ
        });
        const decorativePotMaterial = new THREE.MeshLambertMaterial({
          color: 0xcd853f, // Ø¨Ù†ÙŠ Ø°Ù‡Ø¨ÙŠ
        });

        // Ù†Ø¨Ø§ØªØ§Øª ÙƒØ¨ÙŠØ±Ø© ÙÙŠ Ø§Ù„Ø²ÙˆØ§ÙŠØ§
        const largePlantGeometry = new THREE.SphereGeometry(0.5, 12, 12);
        const mediumPlantGeometry = new THREE.SphereGeometry(0.3, 10, 10);
        const leafyPlantMaterial = new THREE.MeshLambertMaterial({
          color: 0x228b22, // Ø£Ø®Ø¶Ø± ØºØ§Ø¨Ø§Øª
        });
        const softPlantMaterial = new THREE.MeshLambertMaterial({
          color: 0x90ee90, // Ø£Ø®Ø¶Ø± ÙØ§ØªØ­
        });

        // Ù†Ø¨ØªØ© ÙƒØ¨ÙŠØ±Ø© ÙÙŠ Ø§Ù„Ø²Ø§ÙˆÙŠØ© Ø§Ù„ÙŠØ³Ø±Ù‰ Ø§Ù„Ø®Ù„ÙÙŠØ©
        const largePot1 = new THREE.Mesh(
          largePotGeometry,
          decorativePotMaterial
        );
        largePot1.position.set(-9.5, 0.25, 7);
        group.add(largePot1);

        const largePlant1 = new THREE.Mesh(
          largePlantGeometry,
          leafyPlantMaterial
        );
        largePlant1.position.set(-9.5, 0.9, 7);
        group.add(largePlant1);

        // Ø£ÙˆØ±Ø§Ù‚ Ø¥Ø¶Ø§ÙÙŠØ© Ù„Ù„Ù†Ø¨ØªØ© Ø§Ù„ÙƒØ¨ÙŠØ±Ø©
        for (let i = 0; i < 4; i++) {
          const leafGeometry = new THREE.SphereGeometry(0.2, 8, 8);
          const leaf = new THREE.Mesh(leafGeometry, softPlantMaterial);
          const angle = (i * Math.PI) / 2;
          leaf.position.set(
            -9.5 + Math.cos(angle) * 0.4,
            0.7 + Math.sin(i) * 0.2,
            7 + Math.sin(angle) * 0.4
          );
          group.add(leaf);
        }

        // Ù†Ø¨ØªØ© ÙƒØ¨ÙŠØ±Ø© ÙÙŠ Ø§Ù„Ø²Ø§ÙˆÙŠØ© Ø§Ù„ÙŠÙ…Ù†Ù‰ Ø§Ù„Ø®Ù„ÙÙŠØ©
        const largePot2 = new THREE.Mesh(
          largePotGeometry,
          decorativePotMaterial
        );
        largePot2.position.set(9.5, 0.25, 7);
        group.add(largePot2);

        const largePlant2 = new THREE.Mesh(
          largePlantGeometry,
          leafyPlantMaterial
        );
        largePlant2.position.set(9.5, 0.9, 7);
        group.add(largePlant2);

        // Ø£ÙˆØ±Ø§Ù‚ Ø¥Ø¶Ø§ÙÙŠØ© Ù„Ù„Ù†Ø¨ØªØ© Ø§Ù„Ø«Ø§Ù†ÙŠØ©
        for (let i = 0; i < 4; i++) {
          const leafGeometry = new THREE.SphereGeometry(0.2, 8, 8);
          const leaf = new THREE.Mesh(leafGeometry, softPlantMaterial);
          const angle = (i * Math.PI) / 2;
          leaf.position.set(
            9.5 + Math.cos(angle) * 0.4,
            0.7 + Math.sin(i) * 0.2,
            7 + Math.sin(angle) * 0.4
          );
          group.add(leaf);
        }

        // Ù†Ø¨Ø§ØªØ§Øª Ù…ØªÙˆØ³Ø·Ø© Ù…ÙˆØ²Ø¹Ø© ÙÙŠ Ø§Ù„Ù…Ø³Ø§Ø­Ø©
        const mediumPlantPositions = [
          { x: -7, z: 6 },
          { x: 7, z: 6 },
          { x: -9, z: 0 },
          { x: 9, z: 0 },
          { x: 0, z: 7.5 },
        ];

        mediumPlantPositions.forEach((pos) => {
          const mediumPot = new THREE.Mesh(smallPotGeometry, potMaterial);
          mediumPot.position.set(pos.x, 0.15, pos.z);
          group.add(mediumPot);

          const mediumPlant = new THREE.Mesh(
            mediumPlantGeometry,
            softPlantMaterial
          );
          mediumPlant.position.set(pos.x, 0.45, pos.z);
          group.add(mediumPlant);
        });

        // Ø¹Ù†Ø§ØµØ± Ø¯ÙŠÙƒÙˆØ±ÙŠØ© Ù…Ù‡Ø¯Ø¦Ø© - Ù„ÙˆØ­Ø§Øª ÙÙ†ÙŠØ© Ø¨Ø³ÙŠØ·Ø©
        const artPanelGeometry = new THREE.BoxGeometry(1.5, 1, 0.05);
        const artPanelColors = [0xffd4b3, 0xd4edda, 0xbde0ff, 0xf8d7da];

        // Ù„ÙˆØ­Ø© ÙÙ†ÙŠØ© Ø¹Ù„Ù‰ Ø§Ù„Ø¬Ø¯Ø§Ø± Ø§Ù„Ø£ÙŠØ³Ø±
        const artPanel1Material = new THREE.MeshLambertMaterial({
          color: artPanelColors[0],
        });
        const artPanel1 = new THREE.Mesh(artPanelGeometry, artPanel1Material);
        artPanel1.position.set(-10.8, 2.5, -2);
        artPanel1.rotation.y = Math.PI / 2;
        group.add(artPanel1);

        // Ø¥Ø·Ø§Ø± Ø§Ù„Ù„ÙˆØ­Ø©
        const frameGeometry = new THREE.BoxGeometry(1.6, 1.1, 0.08);
        const frameMaterial = new THREE.MeshLambertMaterial({
          color: 0x8b4513,
        });
        const frame1 = new THREE.Mesh(frameGeometry, frameMaterial);
        frame1.position.set(-10.85, 2.5, -2);
        frame1.rotation.y = Math.PI / 2;
        group.add(frame1);

        // Ù„ÙˆØ­Ø© ÙÙ†ÙŠØ© Ø¹Ù„Ù‰ Ø§Ù„Ø¬Ø¯Ø§Ø± Ø§Ù„Ø£ÙŠÙ…Ù†
        const artPanel2Material = new THREE.MeshLambertMaterial({
          color: artPanelColors[1],
        });
        const artPanel2 = new THREE.Mesh(artPanelGeometry, artPanel2Material);
        artPanel2.position.set(10.8, 2.5, -2);
        artPanel2.rotation.y = -Math.PI / 2;
        group.add(artPanel2);

        const frame2 = new THREE.Mesh(frameGeometry, frameMaterial);
        frame2.position.set(10.85, 2.5, -2);
        frame2.rotation.y = -Math.PI / 2;
        group.add(frame2);

        // Ù„Ø§ÙØªØ§Øª Ø¥Ø±Ø´Ø§Ø¯ÙŠØ© Ø¨Ø³ÙŠØ·Ø© ÙˆÙˆØ§Ø¶Ø­Ø©
        const signGeometry = new THREE.BoxGeometry(0.8, 0.4, 0.05);
        const signMaterial = new THREE.MeshLambertMaterial({
          color: 0xe6f3ff, // Ø£Ø²Ø±Ù‚ ÙØ§ØªØ­ Ø¬Ø¯Ø§Ù‹
        });

        // Ù„Ø§ÙØªØ© "Ø§ØºØ³Ù„ ÙŠØ¯ÙŠÙƒ"
        const washHandsSign = new THREE.Mesh(signGeometry, signMaterial);
        washHandsSign.position.set(9, 1.8, -8.85);
        group.add(washHandsSign);

        // Ù„Ø§ÙØªØ© "Ù…Ù†Ø·Ù‚Ø© Ù‡Ø§Ø¯Ø¦Ø©"
        const quietZoneSign = new THREE.Mesh(signGeometry, signMaterial);
        quietZoneSign.position.set(-8, 3.5, -8.85);
        group.add(quietZoneSign);

        // Ù…Ù†Ø·Ù‚Ø© Ù‡Ø§Ø¯Ø¦Ø© Ù…Ø®ØµØµØ© - ÙƒØ±Ø§Ø³ÙŠ Ù…Ø±ÙŠØ­Ø© ÙÙŠ Ø§Ù„Ø²Ø§ÙˆÙŠØ©
        const quietChairGeometry = new THREE.BoxGeometry(0.8, 0.6, 0.8);
        const quietChairMaterial = new THREE.MeshLambertMaterial({
          color: 0xb19cd9, // Ø¨Ù†ÙØ³Ø¬ÙŠ ÙØ§ØªØ­ Ù…Ù‡Ø¯Ø¦
        });

        // ÙƒØ±Ø³ÙŠØ§Ù† ÙÙŠ Ø§Ù„Ù…Ù†Ø·Ù‚Ø© Ø§Ù„Ù‡Ø§Ø¯Ø¦Ø©
        const quietChair1 = new THREE.Mesh(
          quietChairGeometry,
          quietChairMaterial
        );
        quietChair1.position.set(-9, 0.3, 5);
        group.add(quietChair1);

        const quietChair2 = new THREE.Mesh(
          quietChairGeometry,
          quietChairMaterial
        );
        quietChair2.position.set(-7.5, 0.3, 5);
        group.add(quietChair2);

        // Ù…Ø³Ø§Ù†Ø¯ Ù„Ù„ÙƒØ±Ø§Ø³ÙŠ
        const armrestGeometry = new THREE.BoxGeometry(0.8, 0.3, 0.1);
        for (let chair of [quietChair1, quietChair2]) {
          const leftArmrest = new THREE.Mesh(
            armrestGeometry,
            quietChairMaterial
          );
          leftArmrest.position.set(
            chair.position.x,
            0.65,
            chair.position.z - 0.35
          );
          group.add(leftArmrest);

          const rightArmrest = new THREE.Mesh(
            armrestGeometry,
            quietChairMaterial
          );
          rightArmrest.position.set(
            chair.position.x,
            0.65,
            chair.position.z + 0.35
          );
          group.add(rightArmrest);
        }

        // Ø·Ø§ÙˆÙ„Ø© ØµØºÙŠØ±Ø© Ø¨ÙŠÙ† Ø§Ù„ÙƒØ±Ø§Ø³ÙŠ
        const sideTableGeometry = new THREE.CylinderGeometry(
          0.3,
          0.3,
          0.05,
          16
        );
        const sideTableMaterial = new THREE.MeshLambertMaterial({
          color: 0xdaa520,
        });
        const sideTable = new THREE.Mesh(sideTableGeometry, sideTableMaterial);
        sideTable.position.set(-8.25, 0.6, 5);
        group.add(sideTable);

        // Ø³Ø§Ù‚ Ø§Ù„Ø·Ø§ÙˆÙ„Ø© Ø§Ù„Ø¬Ø§Ù†Ø¨ÙŠØ©
        const sideTableLegGeometry = new THREE.CylinderGeometry(
          0.05,
          0.05,
          0.55,
          12
        );
        const sideTableLeg = new THREE.Mesh(
          sideTableLegGeometry,
          tableLegMaterial
        );
        sideTableLeg.position.set(-8.25, 0.275, 5);
        group.add(sideTableLeg);

        return group;
      }

      function createAssembly() {
        const group = new THREE.Group();

        // Ø£Ø±Ø¶ÙŠØ© Ø§Ù„ÙÙ†Ø§Ø¡ Ø§Ù„Ù…Ø­Ø³Ù‘Ù†Ø© Ù…Ø¹ Ø£Ù†Ù…Ø§Ø· ØªÙˆØ¬ÙŠÙ‡ÙŠØ©
        const courtyardGeometry = new THREE.PlaneGeometry(24, 20);
        const courtyardMaterial = new THREE.MeshLambertMaterial({
          color: 0xf5f5dc, // Ø¨ÙŠØ¬ ÙØ§ØªØ­ Ù‡Ø§Ø¯Ø¦
        });
        const courtyard = new THREE.Mesh(courtyardGeometry, courtyardMaterial);
        courtyard.rotation.x = -Math.PI / 2;
        group.add(courtyard);

        // Ø®Ø·ÙˆØ· ØªÙ†Ø¸ÙŠÙ… Ø§Ù„ØµÙÙˆÙ - Ù…Ø±Ø¨Ø¹Ø§Øª ØªÙˆØ¬ÙŠÙ‡ÙŠØ©
        const lineGeometry = new THREE.PlaneGeometry(0.2, 18);
        const lineMaterial = new THREE.MeshLambertMaterial({
          color: 0xe6e6fa, // Ø®Ø²Ø§Ù…ÙŠ ÙØ§ØªØ­
        });

        // Ø®Ø·ÙˆØ· Ø·ÙˆÙ„ÙŠØ© Ù„ØªÙ†Ø¸ÙŠÙ… Ø§Ù„ØµÙÙˆÙ
        for (let i = -3; i <= 3; i++) {
          const line = new THREE.Mesh(lineGeometry, lineMaterial);
          line.rotation.x = -Math.PI / 2;
          line.position.set(i * 3, 0.01, 1);
          group.add(line);
        }

        // Ø®Ø·ÙˆØ· Ø¹Ø±Ø¶ÙŠØ© Ù„ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ù…Ø±Ø§Ø­Ù„
        const crossLineGeometry = new THREE.PlaneGeometry(20, 0.2);
        for (let j = 0; j < 4; j++) {
          const crossLine = new THREE.Mesh(crossLineGeometry, lineMaterial);
          crossLine.rotation.x = -Math.PI / 2;
          crossLine.position.set(0, 0.01, -2 + j * 4);
          group.add(crossLine);
        }

        // Ù…Ù†ØµØ© Ø§Ù„Ù…Ø¯ÙŠØ± ÙˆØ§Ù„Ø¥Ø¯Ø§Ø±Ø©
        const stageGeometry = new THREE.BoxGeometry(8, 0.4, 3);
        const stageMaterial = new THREE.MeshLambertMaterial({
          color: 0xd2b48c, // ØªØ§Ù†
        });
        const stage = new THREE.Mesh(stageGeometry, stageMaterial);
        stage.position.set(0, 0.2, -8);
        group.add(stage);

        // Ø¯Ø±Ø¬Ø§Øª Ø§Ù„Ù…Ù†ØµØ©
        for (let step = 0; step < 3; step++) {
          const stepGeometry = new THREE.BoxGeometry(8.5, 0.15, 0.4);
          const stepMaterial = new THREE.MeshLambertMaterial({
            color: 0xbc9a6a, // Ø¨Ù†ÙŠ ÙØ§ØªØ­
          });
          const stageStep = new THREE.Mesh(stepGeometry, stepMaterial);
          stageStep.position.set(0, 0.075 + step * 0.15, -6.2 - step * 0.4);
          group.add(stageStep);
        }

        // Ø³Ø§Ø±ÙŠØ© Ø§Ù„Ø¹Ù„Ù… Ø§Ù„Ù…Ø­Ø³Ù‘Ù†Ø©
        const flagPoleGeometry = new THREE.CylinderGeometry(0.08, 0.1, 6, 16);
        const flagPoleMaterial = new THREE.MeshLambertMaterial({
          color: 0x708090, // Ø±Ù…Ø§Ø¯ÙŠ Ù…Ø§Ø¦Ù„ Ù„Ù„Ø£Ø²Ø±Ù‚
        });
        const flagPole = new THREE.Mesh(flagPoleGeometry, flagPoleMaterial);
        flagPole.position.set(-5, 3, -8);
        group.add(flagPole);

        // Ù‚Ø§Ø¹Ø¯Ø© Ø³Ø§Ø±ÙŠØ© Ø§Ù„Ø¹Ù„Ù…
        const flagBaseGeometry = new THREE.CylinderGeometry(0.3, 0.4, 0.3, 16);
        const flagBaseMaterial = new THREE.MeshLambertMaterial({
          color: 0x696969,
        });
        const flagBase = new THREE.Mesh(flagBaseGeometry, flagBaseMaterial);
        flagBase.position.set(-5, 0.15, -8);
        group.add(flagBase);

        // Ø§Ù„Ø¹Ù„Ù… Ø§Ù„Ù…Ø­Ø³Ù‘Ù† Ù…Ø¹ Ø£Ù„ÙˆØ§Ù† Ø£ÙØ¶Ù„
        const flagGeometry = new THREE.PlaneGeometry(1.8, 1.2);
        const flagMaterial = new THREE.MeshLambertMaterial({
          color: 0xdc143c, // Ø£Ø­Ù…Ø± Ù‚Ø±Ù…Ø²ÙŠ
        });
        const flag = new THREE.Mesh(flagGeometry, flagMaterial);
        flag.position.set(-4.1, 5, -8);
        group.add(flag);

        // Ù†Ø¬Ù…Ø© Ø£Ùˆ Ø±Ù…Ø² Ø¹Ù„Ù‰ Ø§Ù„Ø¹Ù„Ù…
        const flagSymbolGeometry = new THREE.PlaneGeometry(0.3, 0.3);
        const flagSymbolMaterial = new THREE.MeshLambertMaterial({
          color: 0xffffff,
        });
        const flagSymbol = new THREE.Mesh(
          flagSymbolGeometry,
          flagSymbolMaterial
        );
        flagSymbol.position.set(-4.05, 5, -8);
        group.add(flagSymbol);

        // Ù…Ù†Ø·Ù‚Ø© Ø§Ù„Ù…ÙŠÙƒØ±ÙˆÙÙˆÙ†/Ø§Ù„Ù…Ù†ØµØ©
        const micStandGeometry = new THREE.CylinderGeometry(
          0.03,
          0.03,
          1.5,
          12
        );
        const micStandMaterial = new THREE.MeshLambertMaterial({
          color: 0x2f4f4f,
        });
        const micStand = new THREE.Mesh(micStandGeometry, micStandMaterial);
        micStand.position.set(1, 1.15, -8);
        group.add(micStand);

        // Ø§Ù„Ù…ÙŠÙƒØ±ÙˆÙÙˆÙ†
        const micGeometry = new THREE.SphereGeometry(0.08, 12, 12);
        const micMaterial = new THREE.MeshLambertMaterial({
          color: 0x000000,
        });
        const microphone = new THREE.Mesh(micGeometry, micMaterial);
        microphone.position.set(1, 1.9, -8);
        group.add(microphone);

        // Ù…ÙƒØ¨Ø±Ø§Øª Ø§Ù„ØµÙˆØª
        const speakerGeometry = new THREE.BoxGeometry(0.6, 0.8, 0.4);
        const speakerMaterial = new THREE.MeshLambertMaterial({
          color: 0x2f4f4f,
        });

        // Ù…ÙƒØ¨Ø± ØµÙˆØª ÙŠØ³Ø§Ø±
        const leftSpeaker = new THREE.Mesh(speakerGeometry, speakerMaterial);
        leftSpeaker.position.set(-3, 1.2, -9);
        group.add(leftSpeaker);

        // Ù…ÙƒØ¨Ø± ØµÙˆØª ÙŠÙ…ÙŠÙ†
        const rightSpeaker = new THREE.Mesh(speakerGeometry, speakerMaterial);
        rightSpeaker.position.set(3, 1.2, -9);
        group.add(rightSpeaker);

        // Ø§Ù„Ù…Ø¯ÙŠØ± Ø¹Ù„Ù‰ Ø§Ù„Ù…Ù†ØµØ©
        const principalBodyGeometry = new THREE.CylinderGeometry(
          0.3,
          0.35,
          1.4,
          16
        );
        const principalSuitMaterial = new THREE.MeshLambertMaterial({
          color: 0x2f4f4f, // Ø¨Ø¯Ù„Ø© Ø±Ù…Ø§Ø¯ÙŠØ© Ø¯Ø§ÙƒÙ†Ø©
        });
        const principalBody = new THREE.Mesh(
          principalBodyGeometry,
          principalSuitMaterial
        );
        principalBody.position.set(-1, 1.1, -8);
        group.add(principalBody);

        const principalHeadGeometry = new THREE.SphereGeometry(0.25, 16, 16);
        const principalHeadMaterial = new THREE.MeshLambertMaterial({
          color: 0xfdbcb4,
        });
        const principalHead = new THREE.Mesh(
          principalHeadGeometry,
          principalHeadMaterial
        );
        principalHead.position.set(-1, 1.9, -8);
        group.add(principalHead);

        // Ù…Ø¹Ù„Ù…ÙˆÙ† Ù…Ø±Ø§Ù‚Ø¨ÙˆÙ†
        const teacherBodyGeometry = new THREE.CylinderGeometry(
          0.25,
          0.3,
          1.3,
          16
        );
        const teacherMaterials = [
          new THREE.MeshLambertMaterial({ color: 0x4169e1 }), // Ø£Ø²Ø±Ù‚ Ù…Ù„ÙƒÙŠ
          new THREE.MeshLambertMaterial({ color: 0x8b4513 }), // Ø¨Ù†ÙŠ Ø³Ø±Ø¬
          new THREE.MeshLambertMaterial({ color: 0x2e8b57 }), // Ø£Ø®Ø¶Ø± Ø¨Ø­Ø±ÙŠ
        ];

        const teacherPositions = [
          { x: -8, z: 2 },
          { x: 8, z: 2 },
          { x: -8, z: 6 },
          { x: 8, z: 6 },
          { x: 0, z: 8 },
        ];

        teacherPositions.forEach((pos, index) => {
          const teacherBody = new THREE.Mesh(
            teacherBodyGeometry,
            teacherMaterials[index % teacherMaterials.length]
          );
          teacherBody.position.set(pos.x, 0.65, pos.z);
          group.add(teacherBody);

          const teacherHead = new THREE.Mesh(
            principalHeadGeometry,
            principalHeadMaterial
          );
          teacherHead.position.set(pos.x, 1.4, pos.z);
          group.add(teacherHead);
        });

        // Ø·Ù„Ø§Ø¨ Ù…Ù†Ø¸Ù…ÙˆÙ† ÙÙŠ ØµÙÙˆÙ Ø­Ø³Ø¨ Ø§Ù„Ù…Ø±Ø§Ø­Ù„
        const studentBodyGeometry = new THREE.CylinderGeometry(
          0.2,
          0.25,
          1.1,
          16
        );
        const gradeColors = [
          0xff6b6b, // Ø£Ø­Ù…Ø± ÙØ§ØªØ­ - Ø§Ù„ØµÙ Ø§Ù„Ø£ÙˆÙ„
          0x4ecdc4, // ØªÙŠÙ„ ÙØ§ØªØ­ - Ø§Ù„ØµÙ Ø§Ù„Ø«Ø§Ù†ÙŠ
          0x45b7d1, // Ø£Ø²Ø±Ù‚ ÙØ§ØªØ­ - Ø§Ù„ØµÙ Ø§Ù„Ø«Ø§Ù„Ø«
          0x96ceb4, // Ø£Ø®Ø¶Ø± ÙØ§ØªØ­ - Ø§Ù„ØµÙ Ø§Ù„Ø±Ø§Ø¨Ø¹
          0xffeaa7, // Ø£ØµÙØ± ÙØ§ØªØ­ - Ø§Ù„ØµÙ Ø§Ù„Ø®Ø§Ù…Ø³
          0xdda0dd, // Ø¨Ù†ÙØ³Ø¬ÙŠ ÙØ§ØªØ­ - Ø§Ù„ØµÙ Ø§Ù„Ø³Ø§Ø¯Ø³
        ];

        // Ø·Ù„Ø§Ø¨ Ø§Ù„ØµÙÙˆÙ Ø§Ù„Ù…Ø®ØªÙ„ÙØ©
        for (let grade = 0; grade < 4; grade++) {
          const gradeZ = -2 + grade * 4;
          const studentsPerRow = 5;

          for (let row = 0; row < 3; row++) {
            for (let col = 0; col < studentsPerRow; col++) {
              const studentMaterial = new THREE.MeshLambertMaterial({
                color: gradeColors[grade % gradeColors.length],
              });

              const student = new THREE.Mesh(
                studentBodyGeometry,
                studentMaterial
              );
              const xPos = -6 + col * 3;
              const zPos = gradeZ + row * 0.8;
              student.position.set(xPos, 0.55, zPos);
              group.add(student);

              // Ø±Ø¤ÙˆØ³ Ø§Ù„Ø·Ù„Ø§Ø¨
              const studentHeadGeometry = new THREE.SphereGeometry(
                0.18,
                12,
                12
              );
              const studentHeadMaterial = new THREE.MeshLambertMaterial({
                color: 0xfdbcb4,
              });
              const studentHead = new THREE.Mesh(
                studentHeadGeometry,
                studentHeadMaterial
              );
              studentHead.position.set(xPos, 1.25, zPos);
              group.add(studentHead);

              // Ø­Ù‚Ø§Ø¦Ø¨ Ù…Ø¯Ø±Ø³ÙŠØ©
              if (Math.random() > 0.6) {
                const backpackGeometry = new THREE.BoxGeometry(0.25, 0.3, 0.15);
                const backpackColors = [0x8b4513, 0x2f4f4f, 0x191970, 0x8b0000];
                const backpackMaterial = new THREE.MeshLambertMaterial({
                  color:
                    backpackColors[
                      Math.floor(Math.random() * backpackColors.length)
                    ],
                });
                const backpack = new THREE.Mesh(
                  backpackGeometry,
                  backpackMaterial
                );
                backpack.position.set(xPos + 0.4, 0.3, zPos + 0.3);
                group.add(backpack);
              }
            }
          }
        }

        // Ù…Ù†Ø·Ù‚Ø© Ø®Ø§ØµØ© Ù„Ù„Ø·Ù„Ø§Ø¨ Ø°ÙˆÙŠ Ø§Ù„Ø§Ø­ØªÙŠØ§Ø¬Ø§Øª Ø§Ù„Ø®Ø§ØµØ©
        const specialNeedsAreaGeometry = new THREE.PlaneGeometry(4, 3);
        const specialNeedsAreaMaterial = new THREE.MeshLambertMaterial({
          color: 0xe6f3ff, // Ø£Ø²Ø±Ù‚ ÙØ§ØªØ­ Ø¬Ø¯Ø§Ù‹
          transparent: true,
          opacity: 0.3,
        });
        const specialNeedsArea = new THREE.Mesh(
          specialNeedsAreaGeometry,
          specialNeedsAreaMaterial
        );
        specialNeedsArea.rotation.x = -Math.PI / 2;
        specialNeedsArea.position.set(8, 0.02, 0);
        group.add(specialNeedsArea);

        // ÙƒØ±Ø§Ø³ÙŠ Ù…ØªØ­Ø±ÙƒØ© ÙˆÙ…Ù‚Ø§Ø¹Ø¯ Ù…Ø±ÙŠØ­Ø© ÙÙŠ Ø§Ù„Ù…Ù†Ø·Ù‚Ø© Ø§Ù„Ø®Ø§ØµØ©
        const wheelchairGeometry = new THREE.BoxGeometry(0.6, 0.5, 0.8);
        const wheelchairMaterial = new THREE.MeshLambertMaterial({
          color: 0x708090,
        });

        for (let i = 0; i < 2; i++) {
          const wheelchair = new THREE.Mesh(
            wheelchairGeometry,
            wheelchairMaterial
          );
          wheelchair.position.set(7 + i * 1.2, 0.25, -0.5 + i * 1);
          group.add(wheelchair);

          // Ø¹Ø¬Ù„Ø§Øª Ø§Ù„ÙƒØ±Ø³ÙŠ Ø§Ù„Ù…ØªØ­Ø±Ùƒ
          const wheelGeometry = new THREE.CylinderGeometry(0.3, 0.3, 0.1, 16);
          const wheelMaterial = new THREE.MeshLambertMaterial({
            color: 0x2f2f2f,
          });

          // Ø¹Ø¬Ù„Ø© Ø®Ù„ÙÙŠØ© ÙƒØ¨ÙŠØ±Ø©
          const backWheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
          backWheel.rotation.z = Math.PI / 2;
          backWheel.position.set(7.3 + i * 1.2, 0.3, -0.1 + i * 1);
          group.add(backWheel);

          // Ø¹Ø¬Ù„Ø© Ø£Ù…Ø§Ù…ÙŠØ© ØµØºÙŠØ±Ø©
          const frontWheelGeometry = new THREE.CylinderGeometry(
            0.15,
            0.15,
            0.08,
            12
          );
          const frontWheel = new THREE.Mesh(frontWheelGeometry, wheelMaterial);
          frontWheel.rotation.z = Math.PI / 2;
          frontWheel.position.set(6.7 + i * 1.2, 0.15, -0.9 + i * 1);
          group.add(frontWheel);
        }

        // Ø®Ù„ÙÙŠØ© Ø§Ù„Ù…Ø¯Ø±Ø³Ø© - Ù…Ø¨Ù†Ù‰ Ø§Ù„Ù…Ø¯Ø±Ø³Ø©
        const schoolBuildingGeometry = new THREE.BoxGeometry(20, 6, 2);
        const schoolBuildingMaterial = new THREE.MeshLambertMaterial({
          color: 0xfaf0e6, // ÙƒØ±ÙŠÙ…ÙŠ ÙØ§ØªØ­
        });
        const schoolBuilding = new THREE.Mesh(
          schoolBuildingGeometry,
          schoolBuildingMaterial
        );
        schoolBuilding.position.set(0, 3, -11);
        group.add(schoolBuilding);

        // Ù†ÙˆØ§ÙØ° Ø§Ù„Ù…Ø¯Ø±Ø³Ø©
        const windowGeometry = new THREE.PlaneGeometry(1.2, 1.5);
        const windowMaterial = new THREE.MeshLambertMaterial({
          color: 0x87ceeb,
          transparent: true,
          opacity: 0.7,
        });

        // ØµÙ Ù…Ù† Ø§Ù„Ù†ÙˆØ§ÙØ°
        for (let i = -4; i <= 4; i++) {
          const window = new THREE.Mesh(windowGeometry, windowMaterial);
          window.position.set(i * 2.2, 3.5, -9.9);
          group.add(window);

          // Ø¥Ø·Ø§Ø± Ø§Ù„Ù†Ø§ÙØ°Ø©
          const frameGeometry = new THREE.BoxGeometry(1.3, 1.6, 0.05);
          const frameMaterial = new THREE.MeshLambertMaterial({
            color: 0x8b4513,
          });
          const frame = new THREE.Mesh(frameGeometry, frameMaterial);
          frame.position.set(i * 2.2, 3.5, -9.95);
          group.add(frame);
        }

        // Ø¨Ø§Ø¨ Ø§Ù„Ù…Ø¯Ø±Ø³Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ
        const doorGeometry = new THREE.BoxGeometry(1.5, 2.5, 0.1);
        const doorMaterial = new THREE.MeshLambertMaterial({
          color: 0x8b4513,
        });
        const mainDoor = new THREE.Mesh(doorGeometry, doorMaterial);
        mainDoor.position.set(0, 1.25, -9.9);
        group.add(mainDoor);

        // Ù…Ù‚Ø¨Ø¶ Ø§Ù„Ø¨Ø§Ø¨
        const doorHandleGeometry = new THREE.SphereGeometry(0.05, 8, 8);
        const doorHandleMaterial = new THREE.MeshLambertMaterial({
          color: 0xffd700,
        });
        const doorHandle = new THREE.Mesh(
          doorHandleGeometry,
          doorHandleMaterial
        );
        doorHandle.position.set(0.6, 1.25, -9.85);
        group.add(doorHandle);

        // Ù„Ø§ÙØªØ© Ø§Ù„Ù…Ø¯Ø±Ø³Ø©
        const schoolSignGeometry = new THREE.BoxGeometry(6, 1, 0.1);
        const schoolSignMaterial = new THREE.MeshLambertMaterial({
          color: 0x2f4f4f,
        });
        const schoolSign = new THREE.Mesh(
          schoolSignGeometry,
          schoolSignMaterial
        );
        schoolSign.position.set(0, 5.5, -9.9);
        group.add(schoolSign);

        // Ù†Øµ Ø§Ù„Ù„Ø§ÙØªØ© (Ù…Ø­Ø§ÙƒØ§Ø©)
        const signTextGeometry = new THREE.BoxGeometry(4, 0.3, 0.02);
        const signTextMaterial = new THREE.MeshLambertMaterial({
          color: 0xffffff,
        });
        const signText = new THREE.Mesh(signTextGeometry, signTextMaterial);
        signText.position.set(0, 5.5, -9.85);
        group.add(signText);

        // Ø£Ø´Ø¬Ø§Ø± ÙˆØ­Ø¯Ø§Ø¦Ù‚ Ø­ÙˆÙ„ Ø§Ù„ÙÙ†Ø§Ø¡
        const treeGeometry = new THREE.CylinderGeometry(0.2, 0.3, 2, 12);
        const treeMaterial = new THREE.MeshLambertMaterial({
          color: 0x8b4513,
        });
        const leavesGeometry = new THREE.SphereGeometry(0.8, 12, 12);
        const leavesMaterial = new THREE.MeshLambertMaterial({
          color: 0x228b22,
        });

        // Ø£Ø´Ø¬Ø§Ø± ÙÙŠ Ø§Ù„Ø²ÙˆØ§ÙŠØ§
        const treePositions = [
          { x: -10, z: 8 },
          { x: 10, z: 8 },
          { x: -10, z: -2 },
          { x: 10, z: -2 },
        ];

        treePositions.forEach((pos) => {
          const tree = new THREE.Mesh(treeGeometry, treeMaterial);
          tree.position.set(pos.x, 1, pos.z);
          group.add(tree);

          const leaves = new THREE.Mesh(leavesGeometry, leavesMaterial);
          leaves.position.set(pos.x, 2.5, pos.z);
          group.add(leaves);
        });

        // Ù…Ù‚Ø§Ø¹Ø¯ Ù„Ù„Ø§Ø³ØªØ±Ø§Ø­Ø©
        const benchGeometry = new THREE.BoxGeometry(1.5, 0.1, 0.4);
        const benchMaterial = new THREE.MeshLambertMaterial({
          color: 0x8b4513,
        });
        const benchLegGeometry = new THREE.BoxGeometry(0.1, 0.4, 0.1);

        const benchPositions = [
          { x: -9, z: 6 },
          { x: 9, z: 6 },
        ];

        benchPositions.forEach((pos) => {
          const bench = new THREE.Mesh(benchGeometry, benchMaterial);
          bench.position.set(pos.x, 0.45, pos.z);
          group.add(bench);

          // Ø£Ø±Ø¬Ù„ Ø§Ù„Ù…Ù‚Ø¹Ø¯
          for (let leg = 0; leg < 4; leg++) {
            const benchLeg = new THREE.Mesh(benchLegGeometry, benchMaterial);
            const legX = pos.x + (leg % 2 === 0 ? -0.6 : 0.6);
            const legZ = pos.z + (leg < 2 ? -0.15 : 0.15);
            benchLeg.position.set(legX, 0.2, legZ);
            group.add(benchLeg);
          }

          // Ø¸Ù‡Ø± Ø§Ù„Ù…Ù‚Ø¹Ø¯
          const benchBackGeometry = new THREE.BoxGeometry(1.5, 0.6, 0.1);
          const benchBack = new THREE.Mesh(benchBackGeometry, benchMaterial);
          benchBack.position.set(pos.x, 0.7, pos.z - 0.15);
          group.add(benchBack);
        });

        return group;
      }

      roomObjects.classroom = createClassroom();
      roomObjects.cafeteria = createCafeteria();
      roomObjects.assembly = createAssembly();

      const rooms = {
        classroom: { background: 0xf0f8ff, object: roomObjects.classroom }, // Ø£Ø²Ø±Ù‚ ÙØ§ØªØ­ Ù„Ù„ØµÙ
        cafeteria: { background: 0xfaf5f0, object: roomObjects.cafeteria }, // ÙƒØ±ÙŠÙ…ÙŠ Ø¯Ø§ÙØ¦ Ù„Ù„ÙƒØ§ÙÙŠØªÙŠØ±ÙŠØ§
        assembly: { background: 0xe0f6ff, object: roomObjects.assembly }, // Ø£Ø²Ø±Ù‚ Ø³Ù…Ø§ÙˆÙŠ ÙØ§ØªØ­ Ù„Ù„Ø·Ø§Ø¨ÙˆØ±
      };

      camera.position.set(0, 2, 10);
      camera.lookAt(0, 1, 0);

      const settingsInterface = document.getElementById("settings-interface");
      const levelInterface = document.getElementById("level-interface");
      const roomsInterface = document.getElementById("rooms-interface");
      const exitRoomBtn = document.getElementById("exit-room-btn");

      if (!exitRoomBtn) console.error("Exit button not found");

      function clearScene() {
        // Simple scene clearing - remove all mesh objects except lights
        const toRemove = [];
        scene.children.forEach((child) => {
          if (
            child.type === "Group" ||
            (child.type === "Mesh" && child !== stars)
          ) {
            toRemove.push(child);
          }
          if (child.type === "Points" && child !== stars) {
            toRemove.push(child);
          }
        });

        toRemove.forEach((obj) => {
          scene.remove(obj);
        });
      }

      clearScene();
      scene.add(stars);

      // ØªØ·Ø¨ÙŠÙ‚ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø¥Ø¶Ø§Ø¡Ø© Ø§Ù„Ø£ÙˆÙ„ÙŠØ©
      function initializeBrightness() {
        const brightnessSlider = document.getElementById("brightness");
        if (brightnessSlider) {
          const initialValue = parseFloat(brightnessSlider.value);

          // ØªØ­Ø¯ÙŠØ« Ø¹Ø±Ø¶ Ø§Ù„Ù†Ø³Ø¨Ø© Ø§Ù„Ù…Ø¦ÙˆÙŠØ© Ø§Ù„Ø£ÙˆÙ„ÙŠØ©
          const brightnessDisplay = document.getElementById("brightness-value");
          if (brightnessDisplay) {
            brightnessDisplay.textContent = `${Math.round(
              initialValue * 100
            )}%`;
          }

          // ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ø¥Ø¶Ø§Ø¡Ø© Ø§Ù„Ø£ÙˆÙ„ÙŠØ©
          if (ambientLight) {
            ambientLight.intensity = initialValue;
          }
          if (directionalLight) {
            directionalLight.intensity = initialValue * 0.6;
          }
          if (starMaterial) {
            starMaterial.opacity = initialValue * 0.8;
          }

          // ØªØ­Ø¯ÙŠØ« Ø®Ù„ÙÙŠØ© Ø§Ù„Ù…Ø´Ù‡Ø¯ Ø§Ù„Ø£ÙˆÙ„ÙŠØ©
          if (scene) {
            scene.background = new THREE.Color(0x000000);
          }

          // ØªØ­Ø¯ÙŠØ« Ø¥Ø¶Ø§Ø¡Ø© Ø§Ù„ÙˆØ§Ø¬Ù‡Ø©
          const uiOverlay = document.getElementById("ui-overlay");
          if (uiOverlay) {
            uiOverlay.style.filter = `brightness(${0.8 + initialValue * 0.4})`;
          }
        }
      }

      // ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø£ÙˆÙ„ÙŠØ©
      initializeBrightness();

      // Enhanced brightness control with sound effects
      let lastBrightnessValue = 0.5;
      document.getElementById("brightness").addEventListener("input", (e) => {
        const value = parseFloat(e.target.value);

        // Play sound based on direction
        if (value > lastBrightnessValue) {
          playSound("brightnessUp");
        } else if (value < lastBrightnessValue) {
          playSound("brightnessDown");
        }
        lastBrightnessValue = value;

        // Show brightness indicator
        showIndicator("brightness-indicator", value);

        // ØªØ­Ø¯ÙŠØ« Ø¹Ø±Ø¶ Ø§Ù„Ù†Ø³Ø¨Ø© Ø§Ù„Ù…Ø¦ÙˆÙŠØ©
        const brightnessDisplay = document.getElementById("brightness-value");
        if (brightnessDisplay) {
          brightnessDisplay.textContent = `${Math.round(value * 100)}%`;
        }

        // ØªØ­Ø¯ÙŠØ« Ø¥Ø¶Ø§Ø¡Ø© Ø§Ù„Ù…Ø´Ù‡Ø¯ Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ©
        if (ambientLight) {
          ambientLight.intensity = value;
        }
        if (directionalLight) {
          directionalLight.intensity = value * 0.6;
        }

        // ØªØ­Ø¯ÙŠØ« Ø´ÙØ§ÙÙŠØ© Ø§Ù„Ù†Ø¬ÙˆÙ…
        if (starMaterial) {
          starMaterial.opacity = value * 0.8;
        }

        // ØªØ­Ø¯ÙŠØ« Ø®Ù„ÙÙŠØ© Ø§Ù„Ù…Ø´Ù‡Ø¯ Ø­Ø³Ø¨ Ù…Ø³ØªÙˆÙ‰ Ø§Ù„Ø¥Ø¶Ø§Ø¡Ø©
        if (scene) {
          if (!currentRoom) {
            // ÙÙŠ Ø§Ù„Ø´Ø§Ø´Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ© - Ø§Ù„Ø­ÙØ§Ø¸ Ø¹Ù„Ù‰ Ø§Ù„Ø®Ù„ÙÙŠØ© Ø§Ù„Ø³ÙˆØ¯Ø§Ø¡
            scene.background = new THREE.Color(0x000000);
          } else {
            // ÙÙŠ Ø§Ù„ØºØ±Ù - Ø§Ù„Ø­ÙØ§Ø¸ Ø¹Ù„Ù‰ Ù„ÙˆÙ† Ø§Ù„Ø®Ù„ÙÙŠØ© Ø§Ù„Ø£ØµÙ„ÙŠ Ù…Ø¹ ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø¥Ø¶Ø§Ø¡Ø©
            const roomBg = rooms[currentRoom].background;
            scene.background = new THREE.Color(roomBg);
          }
        }

        // ØªØ­Ø¯ÙŠØ« Ø¥Ø¶Ø§Ø¡Ø© Ø§Ù„Ø¹Ù†Ø§ØµØ± ÙÙŠ Ø§Ù„ÙˆØ§Ø¬Ù‡Ø§Øª
        const uiOverlay = document.getElementById("ui-overlay");
        if (uiOverlay) {
          uiOverlay.style.filter = `brightness(${0.8 + value * 0.4})`;
        }

        console.log(`Brightness updated to: ${value}`);
      });

      // Enhanced volume control with sound effects
      let lastVolumeValue = 0.5;
      document.getElementById("volume").addEventListener("input", (e) => {
        const value = parseFloat(e.target.value);

        // Update master volume
        masterVolume = value;

        // Play sound based on direction
        if (value > lastVolumeValue) {
          playSound("volumeUp");
        } else if (value < lastVolumeValue) {
          playSound("volumeDown");
        }
        lastVolumeValue = value;

        // Show volume indicator
        showIndicator("volume-indicator", value);

        console.log(`Volume updated to: ${value}`);
      });

      document.getElementById("child-name").addEventListener("input", (e) => {
        // Real-time validation and feedback
        const nameInput = e.target;
        const errorEl = document.getElementById("name-error");
        const name = nameInput.value.trim();

        if (name) {
          errorEl.style.display = "none";
          nameInput.style.border = "";
        } else {
          nameInput.style.border = "";
        }

        console.log(`Child's name: ${e.target.value}`);
      });

      // Initialize audio when user first interacts
      const initAudioEvents = isTouch ? ['touchstart', 'touchend'] : ['click'];
      
      function initAudioOnInteraction() {
        initAudio();
        initAudioEvents.forEach(event => {
          document.removeEventListener(event, initAudioOnInteraction);
        });
      }
      
      initAudioEvents.forEach(event => {
        document.addEventListener(event, initAudioOnInteraction, { once: true });
      });

      // Add touch event handlers for better mobile experience
      function addTouchSupport(element, callback) {
        if (isTouch) {
          element.addEventListener('touchstart', (e) => {
            e.preventDefault();
            element.classList.add('loading');
          });
          
          element.addEventListener('touchend', (e) => {
            e.preventDefault();
            element.classList.remove('loading');
            callback();
          });
          
          element.addEventListener('touchcancel', (e) => {
            e.preventDefault();
            element.classList.remove('loading');
          });
        } else {
          element.addEventListener('click', callback);
        }
      }

      // Enhanced button interaction setup
      function setupButtonInteractions() {
        // Settings to Level button
        addTouchSupport(document.getElementById("to-level-btn"), () => {
          playSound("click");
          if (!validateStudentName()) return;
          
          settingsInterface.classList.add("hidden");
          levelInterface.classList.remove("hidden");
          updateStudentInfo();
          console.log("Navigated to Level Interface");
        });

        // Back to settings button
        addTouchSupport(document.getElementById("back-to-settings"), () => {
          playSound("click");
          levelInterface.classList.add("hidden");
          settingsInterface.classList.remove("hidden");
          hideStudentInfo();
          selectedLevel = "";
          console.log("Returned to Settings Interface");
        });

        // Back to levels button  
        addTouchSupport(document.getElementById("back-to-levels"), () => {
          playSound("click");
          clearScene();
          currentRoom = null;
          scene.add(stars);
          scene.background = new THREE.Color(0x000000);
          camera.position.set(0, 2, 10);
          camera.lookAt(0, 1, 0);
          roomsInterface.classList.add("hidden");
          levelInterface.classList.remove("hidden");
          exitRoomBtn.style.display = "none";
          updateStudentInfo();
          console.log("Returned to Level Interface");
        });

        // Level selection buttons
        addTouchSupport(document.getElementById("level-1"), () => {
          playSound("success");
          selectedLevel = "Ø·Ø§Ù„Ø¨ ÙˆÙ…Ø¹Ù„Ù…";
          levelInterface.classList.add("hidden");
          roomsInterface.classList.remove("hidden");
          scene.add(stars);
          scene.background = new THREE.Color(0x000000);
          updateStudentInfo();
          console.log("Selected Level: Ø·Ø§Ù„Ø¨ ÙˆÙ…Ø¹Ù„Ù…");
        });

        addTouchSupport(document.getElementById("level-2"), () => {
          playSound("success");
          selectedLevel = "3 Ø·Ù„Ø§Ø¨ ÙˆÙ…Ø¹Ù„Ù…";
          levelInterface.classList.add("hidden");
          roomsInterface.classList.remove("hidden");
          scene.add(stars);
          scene.background = new THREE.Color(0x000000);
          updateStudentInfo();
          console.log("Selected Level: 3 Ø·Ù„Ø§Ø¨ ÙˆÙ…Ø¹Ù„Ù…");
        });

        addTouchSupport(document.getElementById("level-3"), () => {
          playSound("success");
          selectedLevel = "5 Ø·Ù„Ø§Ø¨ ÙˆÙ…Ø¹Ù„Ù…";
          levelInterface.classList.add("hidden");
          roomsInterface.classList.remove("hidden");
          scene.add(stars);
          scene.background = new THREE.Color(0x000000);
          updateStudentInfo();
          console.log("Selected Level: 5 Ø·Ù„Ø§Ø¨ ÙˆÙ…Ø¹Ù„Ù…");
        });

        // Room selection buttons
        addTouchSupport(document.getElementById("room-classroom"), () => switchRoom("classroom"));
        addTouchSupport(document.getElementById("room-cafeteria"), () => switchRoom("cafeteria"));
        addTouchSupport(document.getElementById("room-assembly"), () => switchRoom("assembly"));

        // Exit room button
        addTouchSupport(exitRoomBtn, () => {
          console.log(`Exiting room: ${currentRoom}`);
          playSound("click");
          
          if (currentRoom) {
            clearScene();
            currentRoom = null;
            scene.add(stars);
            scene.background = new THREE.Color(0x000000);
            camera.position.set(0, 2, 10);
            camera.lookAt(0, 1, 0);
            roomsInterface.classList.remove("hidden");
            exitRoomBtn.style.display = "none";
            updateStudentInfo();
            console.log("Returned to Rooms Interface");
          }
        });
      }

      // Room switching function
      function switchRoom(room) {
        console.log(`Switching to room: ${room}`);
        playSound("success");

        // Check if room exists
        if (!roomObjects[room] || !rooms[room]) {
          console.error(`Room ${room} not found`);
          return;
        }

        // Clear scene and reset
        clearScene();

        // Add room to scene
        scene.add(roomObjects[room]);
        scene.background = new THREE.Color(rooms[room].background);

        // Set camera position for each room with mobile-friendly positioning
        if (room === "classroom") {
          camera.position.set(0, 3, isMobile ? 10 : 8);
          camera.lookAt(0, 1, -2);
        } else if (room === "cafeteria") {
          camera.position.set(2, 5, isMobile ? 16 : 14);
          camera.lookAt(0, 2, 0);
        } else if (room === "assembly") {
          camera.position.set(8, 6, isMobile ? 14 : 12);
          camera.lookAt(0, 2, -2);
        }

        // Update UI
        roomsInterface.classList.add("hidden");
        exitRoomBtn.style.display = "block";
        currentRoom = room;
        updateStudentInfo();
        console.log(`Successfully switched to ${room}`);
      }

      // Remove old event listeners and setup new ones
      setupButtonInteractions();

      function animate() {
        try {
          requestAnimationFrame(animate);
          
          // Reduce animation complexity on mobile devices
          const animationScale = isMobile ? 0.5 : 1.0;
          const timeScale = isMobile ? 0.001 : 0.002;
          
          if (!currentRoom) {
            if (starGeometry && starGeometry.attributes.size) {
              const sizes = starGeometry.attributes.size.array;
              const starCount = sizes.length;
              for (let i = 0; i < starCount; i++) {
                sizes[i] = Math.sin(Date.now() * timeScale + i) * 0.5 + 1.5;
              }
              starGeometry.attributes.size.needsUpdate = true;
            }
            if (stars) {
              stars.rotation.y += 0.001 * animationScale;
            }
          } else {
            // Reduced animation complexity for mobile
            if (currentRoom === "classroom" && roomObjects.classroom) {
              // Simplified teacher movement for mobile
              const teacherBody = roomObjects.classroom.children.find(
                (child) =>
                  child.geometry &&
                  child.geometry.type === "CylinderGeometry" &&
                  child.position.x === -1.5
              );
              const teacherHead = roomObjects.classroom.children.find(
                (child) =>
                  child.geometry && child.geometry.type === "SphereGeometry"
              );

              if (teacherBody && !isMobile) {
                teacherBody.position.y =
                  0.9 + Math.sin(Date.now() * timeScale) * 0.04 * animationScale;
                teacherBody.rotation.y = Math.sin(Date.now() * 0.001) * 0.15 * animationScale;
              }
              if (teacherHead && !isMobile) {
                teacherHead.position.y =
                  1.8 + Math.sin(Date.now() * timeScale) * 0.04 * animationScale;
                teacherHead.rotation.y = Math.sin(Date.now() * 0.0015) * 0.2 * animationScale;
              }

              // Clock animation - reduced on mobile
              if (!isMobile) {
                const clock = roomObjects.classroom.children.find(
                  (child) =>
                    child.geometry &&
                    child.geometry.type === "CylinderGeometry" &&
                    child.position.y > 3
                );
                if (clock) {
                  clock.rotation.z += 0.01 * animationScale;
                }
              }

              // Chair movement - only on desktop
              if (!isMobile) {
                roomObjects.classroom.children.forEach((child, index) => {
                  if (
                    child.geometry &&
                    child.geometry.type === "BoxGeometry" &&
                    child.position.y < 0.3 &&
                    index % 9 === 0
                  ) {
                    child.rotation.y =
                      Math.sin(Date.now() * 0.0008 + index) * 0.06 * animationScale;
                  }
                });
              }
            }
            
            // Similar optimizations for cafeteria and assembly - simplified for mobile
            if (currentRoom === "cafeteria" && roomObjects.cafeteria && !isMobile) {
              // Only animate on desktop for performance
              roomObjects.cafeteria.children.forEach((child, index) => {
                if (
                  child.geometry &&
                  child.geometry.type === "CylinderGeometry" &&
                  child.material.color.getHex() === 0xf0f8ff &&
                  child.position.y > 0.8 &&
                  child.position.y < 1.2
                ) {
                  child.position.y =
                    0.9 + Math.sin(Date.now() * 0.0015 + index) * 0.03 * animationScale;
                  child.rotation.y =
                    Math.sin(Date.now() * 0.0008 + index) * 0.08 * animationScale;
                }
              });
            }

            if (currentRoom === "assembly" && roomObjects.assembly && !isMobile) {
              // Flag animation - desktop only
              roomObjects.assembly.children.forEach((child, index) => {
                if (
                  child.geometry &&
                  child.geometry.type === "PlaneGeometry" &&
                  child.material.color.getHex() === 0xdc143c
                ) {
                  child.rotation.y = Math.sin(Date.now() * timeScale) * 0.15 * animationScale;
                  child.position.x = -4.1 + Math.sin(Date.now() * timeScale) * 0.05 * animationScale;
                }
              });
            }
          }
          renderer.render(scene, camera);
        } catch (error) {
          console.error("Animation error:", error);
        }
      }
      animate();

      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        
        // Mobile-optimized resize handling
        const pixelRatio = isMobile ? Math.min(window.devicePixelRatio, 2) : window.devicePixelRatio;
        renderer.setPixelRatio(pixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        
        // Adjust camera position on orientation change for mobile
        if (isMobile && currentRoom) {
          setTimeout(() => {
            if (currentRoom === "classroom") {
              camera.position.set(0, 3, window.innerHeight < window.innerWidth ? 12 : 10);
            } else if (currentRoom === "cafeteria") {
              camera.position.set(2, 5, window.innerHeight < window.innerWidth ? 18 : 16);
            } else if (currentRoom === "assembly") {
              camera.position.set(8, 6, window.innerHeight < window.innerWidth ? 16 : 14);
            }
          }, 100);
        }
        
        console.log("Window resized - Mobile:", isMobile, "Size:", window.innerWidth + "x" + window.innerHeight);
      });

      // Handle orientation change on mobile
      if (isMobile) {
        window.addEventListener("orientationchange", () => {
          setTimeout(() => {
            window.dispatchEvent(new Event('resize'));
          }, 500);
        });
      }
    </script>
  </body>
</html>
